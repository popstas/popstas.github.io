<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vagrant on Popstas</title>
    <link>http://blog.popstas.ru/tags/vagrant/index.xml</link>
    <description>Recent content in Vagrant on Popstas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <atom:link href="http://blog.popstas.ru/tags/vagrant/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Packer: создаем свои vagrant box и docker image из одного конфига</title>
      <link>http://blog.popstas.ru/blog/2017/03/26/packer-create-vagrant-box-from-ansible-playbook/</link>
      <pubDate>Sun, 26 Mar 2017 21:30:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2017/03/26/packer-create-vagrant-box-from-ansible-playbook/</guid>
      <description>&lt;p&gt;Проект &lt;a href=&#34;https://github.com/viasite-ansible/ansible-server&#34; target=&#34;_blank&#34;&gt;viasite-ansible/ansible-server&lt;/a&gt; подошел к моменту,
когда нужно протестировать роль, которая зависит сразу от нескольких ролей (роль установки сайта).&lt;/p&gt;

&lt;p&gt;Естественно, при тестировании этой роли я не хочу ждать по 10 минут каждый раз,
поэтому &lt;del&gt;я потратил день&lt;/del&gt; я вспомнил, что есть такой тул - &lt;a href=&#34;https://www.packer.io/&#34; target=&#34;_blank&#34;&gt;Packer&lt;/a&gt;
и решил, что пришло его время.&lt;/p&gt;

&lt;p&gt;Packer умеет брать чистую операционку, настраивать ее и упаковывать результат в образ системы для использования в других
программах или разворачивания на хостинге.&lt;/p&gt;

&lt;p&gt;Для чего это может пригодиться:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ускорение тестирования&lt;/li&gt;
&lt;li&gt;б&lt;strong&gt;о&lt;/strong&gt;льшая повторяемость, по сравнению с ansible&lt;/li&gt;
&lt;li&gt;образы для продакшена для быстрого развертывания новых серверов&lt;/li&gt;
&lt;li&gt;образы идентичные продакшену для локальной разработки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tl;dr: я буду собирать образы для Docker и Vagrant из Ubuntu, на которую накатили ansible плейбук.
Gist с результатами &lt;a href=&#34;https://gist.github.com/popstas/9a42d198fe7c5bee317d0bc4e2e2af9f&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2017-03/ansible-packer-docker-vagrant.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;За основу я взял &lt;a href=&#34;https://github.com/geerlingguy/packer-ubuntu-1604&#34; target=&#34;_blank&#34;&gt;geerlingguy/packer-ubuntu-1604&lt;/a&gt;.
Также смотрел на &lt;a href=&#34;https://github.com/chef/bento&#34; target=&#34;_blank&#34;&gt;chef/bento&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;vagrant-provision-vs-packer-build&#34;&gt;Vagrant provision vs Packer build&lt;/h2&gt;

&lt;p&gt;Если брать конкретный момент времени и запустить одновременно &lt;code&gt;vagrant provision&lt;/code&gt; и &lt;code&gt;packer build&lt;/code&gt; с одним и тем же ansible плейбуком,
скорее всего результат будет одинаковым. Но:&lt;/p&gt;

&lt;h4 id=&#34;почему-не-vagrant-provision&#34;&gt;Почему не vagrant provision:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;В packer время тратится только один раз, а в ansible - при создании каждой машины из образа.&lt;/li&gt;
&lt;li&gt;Со временем запуск ansible будет давать немного разные результаты (программы обновляются),
рано или чуть позже это сломает образ, проблемы начнутся, когда это случится не у того, кто написал плейбук
и кто просто хотел запустить систему.&lt;/li&gt;
&lt;li&gt;Можно сделать образы сразу для нескольких систем, за счет того, что сборка происходит параллельно, высоки шансы,
что содержимое образов будет одинаковым.&lt;/li&gt;
&lt;li&gt;На Windows машинах есть проблемы с провиженингом ansible.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;из-чего-состоит-packer&#34;&gt;Из чего состоит Packer&lt;/h2&gt;

&lt;p&gt;На самом деле там больше сущностей, перечислю то, с чем столкнулся я.&lt;/p&gt;

&lt;h3 id=&#34;provisioners-https-www-packer-io-docs-templates-provisioners-html&#34;&gt;&lt;a href=&#34;https://www.packer.io/docs/templates/provisioners.html&#34; target=&#34;_blank&#34;&gt;Provisioners&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Тут все как в Vagrant, provisioners - это то, что ставит все, что нужно, в ваш образ.
Я пользуюсь
&lt;a href=&#34;https://www.packer.io/docs/provisioners/shell.html&#34; target=&#34;_blank&#34;&gt;shell&lt;/a&gt; и
&lt;a href=&#34;https://www.packer.io/docs/provisioners/ansible-local.html&#34; target=&#34;_blank&#34;&gt;ansible-local&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;builders-https-www-packer-io-docs-templates-builders-html&#34;&gt;&lt;a href=&#34;https://www.packer.io/docs/templates/builders.html&#34; target=&#34;_blank&#34;&gt;Builders&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Builders определяют выходные форматы образов.
OpenStack, AWS, Digital Ocean и других хостингов.&lt;/p&gt;

&lt;p&gt;А еще можно &lt;del&gt;грабить корованы&lt;/del&gt; собирать Docker контейнеры. Это удобно тем,
что можно в одном конфиге описать сборку vagrant box и docker image и использовать то и другое по необходимости.&lt;/p&gt;

&lt;p&gt;Необходимость у меня такая: docker образы меньше весят (спасибо слоям) и запускаются мгновенно (2 секунды против 1.5 минут в Vagrant).
С другой стороны, не все роли можно протестировать в Docker. А еще мне кажется, что в среднем программистам проще работать с Vagrant.&lt;/p&gt;

&lt;p&gt;Я использую
&lt;a href=&#34;https://www.packer.io/docs/builders/virtualbox.html&#34; target=&#34;_blank&#34;&gt;virtualbox&lt;/a&gt; и
&lt;a href=&#34;https://www.packer.io/docs/builders/docker.html&#34; target=&#34;_blank&#34;&gt;docker&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;post-rocessors-https-www-packer-io-docs-templates-post-processors-html&#34;&gt;&lt;a href=&#34;https://www.packer.io/docs/templates/post-processors.html&#34; target=&#34;_blank&#34;&gt;Post-rocessors&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Пост-процессоры запаковывают получившиеся артефакты в разные форматы, публикуют их.
Здесь можно протегировать образ, запушить образы в vagrant cloud и в docker hub.&lt;/p&gt;

&lt;p&gt;Я использую
&lt;a href=&#34;https://www.packer.io/docs/post-processors/vagrant.html&#34; target=&#34;_blank&#34;&gt;vagrant&lt;/a&gt; и
&lt;a href=&#34;https://www.packer.io/docs/post-processors/docker-tag.html&#34; target=&#34;_blank&#34;&gt;docker tag&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;packer-build&#34;&gt;packer build&lt;/h2&gt;

&lt;p&gt;Всю магию делает &lt;code&gt;packer build ubuntu1604.json&lt;/code&gt;. Полезные аргументы:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--only=docker&lt;/code&gt;, &lt;code&gt;--only=virtualbox-iso&lt;/code&gt; - полезно для тестирования одного из builders&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--on-error=ask&lt;/code&gt; - позволяет перед убийством виртуалки залезть в нее и посмотреть, что пошло не так&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Перед запуском нужно скачать дистрибутив Ubuntu и положить его туда, куда указывает &lt;code&gt;iso_urls&lt;/code&gt; в настройках билдера.
Итак, запускаем&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;грабли-при-packer-build&#34;&gt;Грабли при packer build&lt;/h2&gt;

&lt;h3 id=&#34;warning-authentication-failure-retrying&#34;&gt;Warning: Authentication failure. Retrying&amp;hellip;&lt;/h3&gt;

&lt;p&gt;После первой удачной сборки при &lt;code&gt;vagrant up&lt;/code&gt; получил такую ошибку:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2200
    default: SSH username: vagrant
    default: SSH auth method: private key
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;При этом через &lt;code&gt;vagrant ssh&lt;/code&gt; можно зайти с паролем &lt;code&gt;vagrant&lt;/code&gt;.
Решение я позаимствовал у &lt;a href=&#34;https://github.com/chef/bento/blob/master/scripts/ubuntu/vagrant.sh&#34; target=&#34;_blank&#34;&gt;chef/bento&lt;/a&gt;,
нужно добавить insecure public key в authorized_keys юзера:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/.ssh
curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vagrant-was-unable-to-mount-virtualbox-shared-folders&#34;&gt;Vagrant was unable to mount VirtualBox shared folders&lt;/h3&gt;

&lt;p&gt;После исправления прошлой проблемы появилась новая:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt; default: Mounting shared folders...
    default: /vagrant =&amp;gt; /Users/popstas/projects/ansible/viasite-ansible/temp
Vagrant was unable to mount VirtualBox shared folders. This is usually
because the filesystem &amp;quot;vboxsf&amp;quot; is not available. This filesystem is
made available via the VirtualBox Guest Additions and kernel module.
Please verify that these guest additions are properly installed in the
guest. This is not a bug in Vagrant and is usually caused by a faulty
Vagrant box. For context, the command attempted was:

mount -t vboxsf -o uid=900,gid=900 vagrant /vagrant

The error output from the command was:

mount: unknown filesystem type &#39;vboxsf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Понятно, что проблема в отсутствии VirtualBox Guest Additions внутри образа. Это странно, потому что в конфиге есть строчки:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;builders&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;[&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;virtualbox-iso&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;guest_additions_path&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;VBoxGuestAdditions_{{.Version}}.iso&amp;quot;&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color: #93A1A1&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color: #93A1A1&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;После чтения &lt;a href=&#34;https://www.packer.io/docs/builders/virtualbox-iso.html#guest_additions_path&#34; target=&#34;_blank&#34;&gt;доки&lt;/a&gt; стало понятно,
что это просто закачивает в образ iso, но не ставит его. Не понял, как это работает у geerlingguy и bento, но для себя решил так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install virtualbox-guest-utils --no-install-recommends
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Хотя чуть позже вычитал у Express 42
&lt;a href=&#34;https://github.com/express42-cookbooks/testo/blob/master/packer/scripts/postinstall.sh#L20-L24&#34; target=&#34;_blank&#34;&gt;как поставить из iso&lt;/a&gt;,
лично я не вижу ничего плохого в установке из пакетов.&lt;/p&gt;

&lt;h3 id=&#34;can-only-tag-from-docker-builder-artifacts-unknown-artifact-type-mitchellh-virtualbox-could-not-open-lock-file-var-lib-dpkg-lock&#34;&gt;Can only tag from Docker builder artifacts, Unknown artifact type: mitchellh.virtualbox, Could not open lock file /var/lib/dpkg/lock&lt;/h3&gt;

&lt;p&gt;Причиной этих ошибок было то, что по умолчанию все provisioners и post-processors применяются ко всем builders.
Так как vagrant и docker отличаются, понадобилось внести изменения:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;внутри скриптов добавлены условия, например, &lt;code&gt;if [ -d /home/vagrant ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;в provisioners и post-processors были вписаны &lt;code&gt;&amp;quot;only&amp;quot;: [&amp;quot;virtualbox-iso&amp;quot;]&lt;/code&gt; и &lt;code&gt;&amp;quot;only&amp;quot;: [&amp;quot;docker&amp;quot;]&lt;/code&gt; куда надо&lt;/li&gt;
&lt;li&gt;в shell provisioners была дописана строчка с &lt;code&gt;override&lt;/code&gt;, которая запускает скрипт от имени vagrant и не влияет на docker builder:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;provisioners&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;[&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;shell&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;script&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;packer/scripts/ansible.sh&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;override&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;virtualbox-iso&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;{&lt;/span&gt;
          &lt;span style=&#34;color: #268BD2&#34;&gt;&amp;quot;execute_command&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;echo &amp;#39;vagrant&amp;#39; | {{.Vars}} sudo -S -E bash &amp;#39;{{.Path}}&amp;#39;&amp;quot;&lt;/span&gt;
        &lt;span style=&#34;color: #93A1A1&#34;&gt;}&lt;/span&gt;
      &lt;span style=&#34;color: #93A1A1&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;сборка-docker-застывала-в-конце&#34;&gt;Сборка Docker застывала в конце&lt;/h3&gt;

&lt;p&gt;Не понял, с чем это связано, но заствала она на &lt;code&gt;apt autoremove&lt;/code&gt;, не стал разбираться ради экономии 20 мб, просто убрал этот шаг.&lt;/p&gt;

&lt;h2 id=&#34;итог&#34;&gt;Итог&lt;/h2&gt;

&lt;p&gt;Я получил готовый vagrant box, из которого можно поднять виртуалку за 1.5 минуты или контейнер за секунду, вместо 10 минут. Profit!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Разворачиваем Drupal 8 с помощью Otto</title>
      <link>http://blog.popstas.ru/blog/2015/12/14/drupal-8-with-otto/</link>
      <pubDate>Mon, 14 Dec 2015 08:16:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2015/12/14/drupal-8-with-otto/</guid>
      <description>&lt;p&gt;Репост &lt;a href=&#34;https://habrahabr.ru/post/273009/&#34; target=&#34;_blank&#34;&gt;моей статьи&lt;/a&gt; с хабра.&lt;/p&gt;

&lt;p&gt;Этот пост получился в результате моего ознакомления с Otto, одним из последних продуктов Hashicorp,
о котором уже была &lt;a href=&#34;http://habrahabr.ru/post/268497/&#34;&gt;обзорная статья&lt;/a&gt; на хабре.&lt;/p&gt;

&lt;p&gt;Мой пост носит более практический характер. Я решил поднять на otto стандартный проект,
чтобы сразу не наткнуться на тонкости настройки, а чтобы было интересно, выбрал Drupal 8, вышедший недавно.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/6d4/ec4/b47/6d4ec4b4786f47048d5fd55301234115.png&#34; alt=&#34;image&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;установка&#34;&gt;Установка&lt;/h2&gt;

&lt;p&gt;Последняя версия, отмеченная тегом - 0.1.2 от 20.10.2015. Забегая вперед, скажу, что у меня не получилось сходу настроить MySQL на ней,
а еще, заглянув в CHANGELOG, решил попробовать master ветку из-за Layered Dev Environments.&lt;/p&gt;

&lt;p&gt;Otto 0.1.3-dev требует Vagrant 1.7.99+, &lt;del&gt;так как стабильная версия 1.7.4, это значит, что Vagrant тоже нужен из master ветки&lt;/del&gt;.
UPD: вышел Vagrant 1.8, собирать Vagrant больше не надо.&lt;/p&gt;

&lt;p&gt;Компиляция обоих проектов хорошо описана на страницах &lt;a href=&#34;https://github.com/hashicorp/otto&#34; target=&#34;_blank&#34;&gt;otto&lt;/a&gt; и &lt;a href=&#34;https://github.com/mitchellh/vagrant&#34; target=&#34;_blank&#34;&gt;vagrant&lt;/a&gt;,
мне хватило полчаса, чтобы поставить golang, настроить gopath и скомпилировать оба проекта без знания Go и Ruby.
Главное не забыть добавить&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$GOPATH/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Перезапускаем терминал, проверяем, что у нас запускаются dev-версии: &lt;code&gt;vagrant version&lt;/code&gt;, &lt;code&gt;otto version&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;настройка-nfs&#34;&gt;Настройка NFS&lt;/h3&gt;

&lt;p&gt;Напрямую к otto не относится, но, узнав об &lt;a href=&#34;http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines&#34; target=&#34;_blank&#34;&gt;ужасной тормознутости&lt;/a&gt;
стандартных virualbox shared folders, осознал необходимость настроить NFS.&lt;/p&gt;

&lt;p&gt;На Ubuntu достаточно установить пакеты nfs-common nfs-kernel-server и добавить в /etc/sudoers несколько строк,
чтобы Vagrant не спрашивал пароль при каждом запуске, подробнее &lt;a href=&#34;https://docs.vagrantup.com/v2/synced-folders/nfs.html&#34; target=&#34;_blank&#34;&gt;в документации&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;подготовка-проекта&#34;&gt;Подготовка проекта&lt;/h2&gt;

&lt;p&gt;Скачаем Drupal 8:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/drupal/drupal.git drupal8
cd drupal8
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;appfile&#34;&gt;Appfile&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ottoproject.io/docs/concepts/appfile.html&#34; target=&#34;_blank&#34;&gt;Appfile&lt;/a&gt; - основной файл конфигурации otto для проекта, должен быть в корне проекта.&lt;/p&gt;

&lt;p&gt;Вообще его может вообще не быть, тогда otto сам определит требования к окружению, в котором может запуститься приложение.
Логика определения типа приложения проще некуда, например, проект будет определен как php, если в корне есть файлы *.php&lt;/p&gt;

&lt;h3 id=&#34;otto-compile&#34;&gt;otto compile&lt;/h3&gt;

&lt;p&gt;Первая команда, которая нужна в otto - &lt;a href=&#34;https://www.ottoproject.io/docs/concepts/compile.html&#34; target=&#34;_blank&#34;&gt;otto compile&lt;/a&gt;.
Она анализирует проект и его Appfile, после чего генерирует дерево в папке .otto, содержащее всю информацию о конфигурации dev и deploy окружений.&lt;/p&gt;

&lt;p&gt;Документация советует не править руками содержимое этой папки. Но смотреть можно и нужно.&lt;/p&gt;

&lt;p&gt;Также будет сгенерирован &lt;code&gt;.ottoid&lt;/code&gt; - уникальный идентификатор вашего приложения, по которому otto будет отслеживать его деплой, хранить историю, использовать его как зависимость и т.д.&lt;/p&gt;

&lt;p&gt;К этому моменту наше окружение описано и готово к развертыванию.&lt;/p&gt;

&lt;h3 id=&#34;otto-dev&#34;&gt;otto dev&lt;/h3&gt;

&lt;p&gt;Следующее, что нужно - развернуть локальное dev окружение на локальной машине.
По сути, otto dev - то же самое, что vagrant up.&lt;/p&gt;

&lt;h4 id=&#34;layered-dev-environments&#34;&gt;Layered Dev Environments&lt;/h4&gt;

&lt;p&gt;Интересна концепция слоев, они очень похожи на слои Docker: при первом запуске &lt;code&gt;otto dev&lt;/code&gt; виртуальное окружение Vagrant будет настраиваться последовательно,
делая снимок после каждого шага. Слои описаны в типе приложения. Всё это позволяет сильно сократить время пересоздания dev окружения.
Таким образом, мы получаем мгновенный запуск готового окружения даже при полном пересоздании виртуальной машины.
Разница между перезапуском и пересозданием машины (&lt;code&gt;otto dev halt &amp;amp;&amp;amp; time otto dev&lt;/code&gt; и &lt;code&gt;otto dev destroy &amp;amp;&amp;amp; time otto dev&lt;/code&gt;) составляет около 5 секунд.&lt;/p&gt;

&lt;p&gt;Судя по changelog, vagrant этот функционал не получит, по крайней мере в следующей версии, зато в Vagrant появится функционал для создания snapshots.&lt;/p&gt;

&lt;p&gt;Посмотреть слои можно командой &lt;code&gt;otto dev layers&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ otto dev layers
consul
php5.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в случае PHP приложения, otto должен выдать дальнейшие инструкции:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ otto dev
IP address: 100.66.143.21

A development environment has been created for writing a PHP app.

You can access the environment from this machine using the IP address above.
For example, if you start your app with &#39;php -S 0.0.0.0:5000&#39;, then you can
access it using the above IP at port 5000.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Что мы получили с автоматической настройкой?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 12.04 (на данный момент нельзя выбирать базовый образ системы)&lt;/li&gt;
&lt;li&gt;Consul&lt;/li&gt;
&lt;li&gt;PHP 5.6 (otto устанавливает PHP не из стандартного репозитория, а из PPA)&lt;/li&gt;
&lt;li&gt;Composer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Для работы Drupal критически не хватает MySQL.&lt;/p&gt;

&lt;h3 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h3&gt;

&lt;p&gt;Простейший способ добавить MySQL: указать зависимость. Создадим Appfile в корне проекта:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application {
    name = &amp;quot;drupal8&amp;quot;
    type = &amp;quot;php&amp;quot;

    dependency {
        source = &amp;quot;github.com/hashicorp/otto/examples/mysql&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Этот конфиг явно указывает тип приложения (php) и добавляет MySQL как зависимость.
Несмотря на то, что ссылка в source невалидная, otto ее поймет, есть и &lt;a href=&#34;https://www.ottoproject.io/docs/appfile/dep-sources.html&#34; target=&#34;_blank&#34;&gt;другие форматы source&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Есть способ добавить mysql еще проще, но он неправильный, я скажу о нем в недостатках.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/blob/master/examples/mysql/Appfile&#34; target=&#34;_blank&#34;&gt;Appfile mysql&lt;/a&gt; описывает зависимое приложение как Docker-контейнер,
путь к образу контейнера и параметры запуска. В результате мы получим запущенный контейнер внутри Vagrant,
благодаря Consul он будет доступен по адресу mysql.service.consul (внутри виртуалки) с юзером и паролем root:root.
Настроенный по умолчанию Consul существенно облегчает использование Docker, можно не разбираться в тонкостях настройки service discovery, а просто пользоваться.&lt;/p&gt;

&lt;p&gt;Зависимостью может быть любое другое приложение, но настоятельно рекомендуется, чтобы оно имело .ottoid файл,
который позволит otto понять, что он запускает, даже если приложение будет переименовано.&lt;/p&gt;

&lt;p&gt;Зависимости в данный момент не поддерживают версионность (в будущем обещают добавить),
это значит, что при каждом &amp;lsquo;otto compile&amp;rsquo; у вас есть шанс получить не то, что вы ожидали,
поэтому стоит форкнуть зависимости себе или положить на локальной машине.&lt;/p&gt;

&lt;p&gt;Делаем &lt;code&gt;otto compile&lt;/code&gt;, &lt;code&gt;otto dev destroy&lt;/code&gt;, &lt;code&gt;otto dev&lt;/code&gt; - получаем машину, готовую к запуску Drupal. Осталось запустить в ней сервер.&lt;/p&gt;

&lt;h3 id=&#34;otto-dev-ssh&#34;&gt;otto dev ssh&lt;/h3&gt;

&lt;p&gt;Заходим в виртуалку по SSH. Выполняем указанную выше команду запуска встроенного в PHP web-сервера, я не вижу ничего плохого в запуске под root на 80 порту на dev:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo php -S 0.0.0.0:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого можно заходить открывать в браузере IP адрес, который выдал &amp;lsquo;otto dev&amp;rsquo;, можно его получить явно, выполнив &amp;lsquo;otto dev address&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h2&gt;

&lt;h3 id=&#34;сырой-код&#34;&gt;Сырой код&lt;/h3&gt;

&lt;p&gt;Видно, что код местами довольно прототипный. Например, в Vagrantfile используется bash для разворачивания окружения, а не ansible или что-то подобное.&lt;/p&gt;

&lt;p&gt;Я заглянул в код App type php, нашел там определение того, что запускаемое приложение - wordpress (по наличию файла wp-config.php),
единственное отличие от стандартного php приложения - автоматическое добавление mysql в зависимости.
То есть сейчас можно указать в Appfile &lt;code&gt;type = &amp;quot;wordpress&amp;quot;&lt;/code&gt; или сделать &lt;code&gt;touch wp-config.php&lt;/code&gt;, чтобы получить mysql, но, конечно, так делать не стоит.&lt;/p&gt;

&lt;h3 id=&#34;окружения-не-проработаны&#34;&gt;Окружения не проработаны&lt;/h3&gt;

&lt;p&gt;Судя по issue tracker проекта, best practices еще не готовы и не совсем понятно, как будут готовиться.
Например, в случае PHP, есть Hashicorp, которые не знают особенностей окружения PHP проектов и программисты PHP, которые не знают Go и не могут отправить pull request.&lt;/p&gt;

&lt;p&gt;Митчелл Хашимото, автор Otto, предлагает всем заинтересованным писать на Github предложения с улучшениями,
ссылки на статьи с настройкой правильного окружения, а Hashicorp позаботится об их интеграции в продукт.
Мне кажется, что позже появятся абстракции, которые дадут возможность широкому кругу не-go программистов помогать в развитии продукта.&lt;/p&gt;

&lt;h3 id=&#34;dev-отличается-от-prod&#34;&gt;Dev отличается от prod&lt;/h3&gt;

&lt;p&gt;До команд &lt;code&gt;otto infra&lt;/code&gt; и &lt;code&gt;otto deploy&lt;/code&gt; я не добрался, но узнал, что сейчас они поддерживают только AWS
и что для php проектов dev-окружение отличается от deploy-окружения, в первом случае предлагается запускать встроенный в PHP сервер,
во втором поднимается apache2 с mod-php.&lt;/p&gt;

&lt;h3 id=&#34;dev-плохо-кастомизируется&#34;&gt;Dev плохо кастомизируется&lt;/h3&gt;

&lt;p&gt;Otto в данный момент не дает возможность кастомизировать Vagrantfile dev-окружения через Appfile.
Смотрим &lt;code&gt;.otto/compiled/app/dev/Vagrantfile&lt;/code&gt;, оказывается, в нем прописаны параметры монтирования /vagrant, несовместимые с NFS. Исправляем строку на что-то вроде:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.synced_folder &#39;/home/popstas/projects/site/drupal8&#39;, &amp;quot;/vagrant&amp;quot;, type: &amp;quot;nfs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Следующий &lt;code&gt;otto compile&lt;/code&gt; затрет эти изменения.&lt;/p&gt;

&lt;p&gt;Единственный способ сделать правильно: полностью переопределить Vagrantfile, используя application type = &amp;ldquo;custom&amp;rdquo;,
но в таком случае вся магия автонастройки окружения пропадает.&lt;/p&gt;

&lt;h2 id=&#34;выводы&#34;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Я сделал для себя вывод, что Otto еще не готов для полноценного использования, на что в общем-то намекает версия продукта 0.1.
Тем не менее продукт очень интересный и уже сейчас имеет преимущества по сравнению с Vagrant, а все недостатки объясняются новизной Otto,
разработчики о них знают и имеют планы по устранению.&lt;/p&gt;

&lt;p&gt;Сейчас непонятно, как создавать свои слои, когда слои появятся в Otto полноценно, для меня это будет достаточной причиной, чтобы перейти на него с Vagrant&amp;rsquo;а.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>