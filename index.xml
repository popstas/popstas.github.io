<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Popstas</title>
    <link>http://blog.popstas.ru/index.xml</link>
    <description>Recent content on Popstas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Sun, 05 Mar 2017 20:45:00 +0000</lastBuildDate>
    <atom:link href="http://blog.popstas.ru/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Перенос блога с Octopress на Hugo</title>
      <link>http://blog.popstas.ru/blog/2017/03/05/migrate-from-octopress-to-hugo/</link>
      <pubDate>Sun, 05 Mar 2017 20:45:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2017/03/05/migrate-from-octopress-to-hugo/</guid>
      <description>&lt;p&gt;Эта статья первая на новом движке.&lt;/p&gt;

&lt;h4 id=&#34;зачем&#34;&gt;Зачем:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Не зависеть от ruby&lt;/li&gt;
&lt;li&gt;быстрее&lt;/li&gt;
&lt;li&gt;просто интересно&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2017-03/octopress-to-hugo.png&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;подробнее-о-причинах&#34;&gt;Подробнее о причинах&lt;/h2&gt;

&lt;h3 id=&#34;не-зависеть-от-ruby&#34;&gt;Не зависеть от ruby&lt;/h3&gt;

&lt;p&gt;Это было главной причиной. Однажды я захотел написать статью, но &lt;code&gt;rake&lt;/code&gt; в папке проекта перестал работать.
Оказалось, что Octopress не совместим с текущим ruby 2.4 (что намекает на то, что проект бросают).&lt;/p&gt;

&lt;p&gt;Можно было сделать песочницу с ruby 2.3 для конеретного проекта, но я с руби сталкивался мало (Vagrant, Octopress)
и большого желания познавать его не было. Поэтому я просто переключал системную версию руби:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew switch ruby 2.3.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого начинал работать Octopress, но переставал работать Vim.&lt;/p&gt;

&lt;p&gt;Пробовал скачать контейнер с Octopress, но тоже за 20 минут не разобрался, как с ним жить: внутри нет git для деплоя,
порт для &lt;code&gt;rake preview&lt;/code&gt; не открыт&amp;hellip; нафиг.&lt;/p&gt;

&lt;p&gt;С Hugo такого безобразия не должно быть, т.к. он написан на Go и содержит один бинарник, ничего не требуя от системы.&lt;/p&gt;

&lt;h3 id=&#34;быстрее&#34;&gt;Быстрее&lt;/h3&gt;

&lt;p&gt;Так как я пишу 5 раз в год, меня это не очень волновало, но все-таки скорость впечетляет:
мой блог на данный момент состоит примерно из 85 страниц, Hugo генерирует их за 30 мс!&lt;/p&gt;

&lt;p&gt;Самое приятное в этом то, что в Hugo есть live reload: страница в браузере обновляется сама при редактировании исходника.&lt;/p&gt;

&lt;h2 id=&#34;установка&#34;&gt;Установка&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/codebrane/octohug&#34; target=&#34;_blank&#34;&gt;Устанавливаем&lt;/a&gt; в систему, я сделал так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для подсветки кода ему нужен &lt;code&gt;pygments&lt;/code&gt;, ставим его:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если вы любите &lt;a href=&#34;http://ethanschoonover.com/solarized&#34; target=&#34;_blank&#34;&gt;Solarized Dark&lt;/a&gt; как люблю его я, ставим тему для pygments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/john2x/solarized-pygment.git
cd solarized-pygment
./setup.py install
cd ..
rm -rf solarized-pygment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Переходим в папку, где будет новый проект. У меня блог лежал в &lt;code&gt;~/projects/site/blog.popstas.ru&lt;/code&gt;,
я заранее переименовал старый проект в &lt;code&gt;~/projects/site/blog.popstas.ru_octopress&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Создаем новый сайт:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new site blog.popstas.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Получаем следующее:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree blog.popstas.ru

blog.popstas.ru
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Переходим в папку нового блога.&lt;/p&gt;

&lt;p&gt;Добавляем тему. Я искал порт своей темы Octopress на Hugo и &lt;a href=&#34;https://github.com/parsiya/Hugo-Octopress&#34; target=&#34;_blank&#34;&gt;нашел&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir themes
git clone https://github.com/parsiya/Hugo-Octopress octopress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вносим первые правки в &lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseURL = &amp;quot;http://blog.popstas.ru/&amp;quot;
languageCode = &amp;quot;ru-ru&amp;quot;
title = &amp;quot;Popstas&amp;quot;
theme = &amp;quot;octopress&amp;quot;

[params]
    # Keep it as false please, the css file contains the code for highlighting
    pygmentsuseclasses = false
    
    # If nothing is set, then solarized_light is used
    # Other styles can be viewed in [http://pygments.org/](http://pygments.org/)
    pygmentsstyle = &amp;quot;solarized_dark&amp;quot;
    
    # Highlight shortcode and code fences (```) will be treated similarly
    pygmentscodefences = true

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;перенос-контента&#34;&gt;Перенос контента&lt;/h2&gt;

&lt;p&gt;Определим список задач:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Перенести md файлы&lt;/li&gt;
&lt;li&gt;Сохранить урлы статей&lt;/li&gt;
&lt;li&gt;Перенести тему, чтобы внешне были минимальные изменения&lt;/li&gt;
&lt;li&gt;Перенести правки css темы&lt;/li&gt;
&lt;li&gt;Сохранить форматирование статей&lt;/li&gt;
&lt;li&gt;Перенести картинки&lt;/li&gt;
&lt;li&gt;Перенести фавиконку и CNAME (для привязки домена к github pages)&lt;/li&gt;
&lt;li&gt;Сохранить Disqus комменты и Google Analytics&lt;/li&gt;
&lt;li&gt;Сохранить RSS ленту&lt;/li&gt;
&lt;li&gt;Перенести содержимое боковой колонки (последние статьи, лента твиттера, проекты на github)&lt;/li&gt;
&lt;li&gt;Перенести соц. панель AddToAny&lt;/li&gt;
&lt;li&gt;Русифицировать&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;перенос-md-файлов&#34;&gt;Перенос md файлов&lt;/h3&gt;

&lt;p&gt;В hugo есть только миграция с Jekyl, поэтому идем на github, ищем &amp;ldquo;octopress hugo&amp;rdquo; и находим &lt;a href=&#34;https://github.com/codebrane/octohug&#34; target=&#34;_blank&#34;&gt;octohug&lt;/a&gt;.
Его нужно скачать, скомпилировать, скопировать в папку старого блога и запустить.&lt;/p&gt;

&lt;p&gt;После этого в корне старого блога появится папка &lt;code&gt;content&lt;/code&gt;, ее нужно перенести в новый блог:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/codebrane/octohug
cd &amp;quot;$GOPATH/src/github.com/codebrane/octohug&amp;quot;
go build
cp octohug ~/projects/site/blog.popstas.ru_octopress

cd ~/projects/site/blog.popstas.ru_octopress
./octohug

mv content ../blog.popstas.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пора посмотреть, что получается. Переходим в папку нового блога и запускаем генератор:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/projects/site/blog.popstas.ru
hugo serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Лично мне результат не понравился :) Статьи перенеслись, но с кривыми датами, заголовками и форматированием.
Открываем оба блога в вашем редакторе и на следующие пару часов превращаемся в контентщика. Вот что правил я:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt; заменить на &lt;code&gt;HUGOMORE42&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;перекопировать титлы (обратите внимание, из &lt;code&gt;title: &amp;quot;title&amp;quot;&lt;/code&gt; надо делать &lt;code&gt;title = &amp;quot;title&amp;quot;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;убрать из &lt;code&gt;slug&lt;/code&gt; даты&lt;/li&gt;
&lt;li&gt;поправить все даты&lt;/li&gt;
&lt;li&gt;заменить все &lt;code&gt;{[процентик]img&lt;/code&gt; на &lt;code&gt;&amp;lt;img src&lt;/code&gt; (заменил &lt;code&gt;%&lt;/code&gt; на &lt;code&gt;[процентик]&lt;/code&gt;, Github ругался)&lt;/li&gt;
&lt;li&gt;перекопировать теги, где они не перенеслись. Также я заменил &lt;code&gt;Categories =&lt;/code&gt; на &lt;code&gt;Tags =&lt;/code&gt;, это сломало старые урлы категорий,
но зато сделало теги тегами&lt;/li&gt;
&lt;li&gt;пройтись по каждой статье и глазами найти остальные несоответствия&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вносим правки в &lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disablePathToLower = false
paginate = 10

# Make tags and categories work
[indexes]
    tag = &amp;quot;tags&amp;quot;
    category = &amp;quot;categories&amp;quot;

[params]
    # If false, all of the post will appear on front page (and in pagination)
    truncate = true
    
    # Author&#39;s name (this will appear in metadata and under posts)
    author = &amp;quot;Stanislav Popov&amp;quot;
    
    # This text appears in the site header under website title
    subtitle = &amp;quot;Записки о Linux&amp;quot;
    
    # Website&#39;s default description
    defaultDescription = &amp;quot;&amp;quot;

    # Used in the search engine
    searchEngineURL = &amp;quot;https://www.google.com/search&amp;quot;

[blackfriday]
    hrefTargetBlank = true # open the external links in a new window
    fractions = false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;урлы&#34;&gt;Урлы&lt;/h3&gt;

&lt;p&gt;Урлы зависят не от имени файла (оно может быть любым), а от шаблона урлов, в моем случае от даты и алиаса (slug).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[permalinks]
    post = &amp;quot;/blog/:year/:month/:day/:slug/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;правки-css-темы&#34;&gt;Правки CSS темы&lt;/h3&gt;

&lt;p&gt;К сожалению препроцессора не будет.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
    customCSS = [&amp;quot;css/custom.css&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;картинки-и-прочая-статика&#34;&gt;Картинки и прочая статика&lt;/h3&gt;

&lt;p&gt;Копируем все, что должно быть в корне сайта из &lt;code&gt;sources&lt;/code&gt; в &lt;code&gt;static&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;discus&#34;&gt;Discus&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
    # Disqus shortcode
    # Disable comments for a specific post by adding &amp;quot;comments: false&amp;quot; in its frontmatter
    disqusShortname = &amp;quot;popstas&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комменты появятся только при деплое, на localhost они отключены по каким-то причинам.&lt;/p&gt;

&lt;h3 id=&#34;google-analytics&#34;&gt;Google Analytics&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
    # Google analytics account id
    googleAnalytics = &amp;quot;UA-70438594-1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rss&#34;&gt;RSS&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
    rss = true  # switch to true to enable RSS icon link

    # Set to true to use a text label for RSS instead of an icon
    # This is overwritten by the `rss` setting
    textrss = false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;боковая-колонка-последние-посты&#34;&gt;Боковая колонка: последние посты&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
	# Number of recent posts that will be shown in the sidebar - set to 0 or remove to hide this section
	sidebarRecentLimit = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;боковая-колонка-twitter-лента-проекты-на-github&#34;&gt;Боковая колонка: Twitter лента, проекты на Github&lt;/h3&gt;

&lt;p&gt;Кастомные виджеты sidebar не предусматривает, поэтому правим шаблон, дописываем в конец, перед &lt;code&gt;&amp;lt;/aside&amp;gt;&lt;/code&gt;:
&lt;code&gt;/themes/octopress/layouts/partials/sidebar.html&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;    {{ partial &amp;quot;custom/twitterfeed.html&amp;quot; . }}
    
    {{ partial &amp;quot;custom/github.html&amp;quot; . }}
&lt;span style=&#34;color: #93A1A1&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;aside&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;После чего создаем в &lt;code&gt;themes/octopress/layouts/partials/custom&lt;/code&gt; соответствующие файлы и копируем туда шаблоны из Octopress.
При этом нужно заменить переменные с &lt;code&gt;{{ site.var_name }}&lt;/code&gt; на &lt;code&gt;{{ .Site.Params.varName }}&lt;/code&gt; и добавить в &lt;code&gt;config.toml&lt;/code&gt; нужные переменные:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[params]
    # Twitter feed
    twitterUsername = &amp;quot;popstas&amp;quot;
    # http://raisedadead.com/octopress-twitter-aside/
    twitterWidgetId = 691684611357806592

    # Github repos
    githubUser = &amp;quot;popstas&amp;quot;
    githubRepoCount = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Код виджетов здесь:
&lt;a href=&#34;https://github.com/popstas/popstas.github.io/tree/master/themes/octopress/partials/custom/twitterfeed.html&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt;
и
&lt;a href=&#34;https://github.com/popstas/popstas.github.io/tree/master/themes/octopress/partials/custom/github.html&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;соц-панель-addtoany&#34;&gt;Соц. панель AddToAny&lt;/h3&gt;

&lt;p&gt;С соц. панелью поступил так же, как и с виджетами боковой колонки: шаблон в &lt;code&gt;partials/custom&lt;/code&gt;, вставил в &lt;code&gt;/themes/octopress/layouts/partials/post_footer.html:18&lt;/code&gt;,
там есть специальное место для соц. панели.&lt;/p&gt;

&lt;h2 id=&#34;русификация&#34;&gt;Русификация&lt;/h2&gt;

&lt;p&gt;Поменял формат дат в &lt;code&gt;themes/octopress/layouts/partials/post_header.html&lt;/code&gt; и &lt;code&gt;themes/octopress/layouts/partials/post_footer.html&lt;/code&gt;,
было: &lt;code&gt;{{ .Date.Format &amp;quot;Jan 2, 2006&amp;quot; }}&lt;/code&gt;, стало: &lt;code&gt;{{ .Date.Format &amp;quot;2 Jan 2006, 15:04&amp;quot; }}&lt;/code&gt;,
подробности &lt;a href=&#34;https://golang.org/pkg/time/#Time.Format&#34; target=&#34;_blank&#34;&gt;тут&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Настройка кеширующего прокси apt-cacher-ng для ускорения тестирования ansible ролей с Molecule, Gitlab CI и Docker</title>
      <link>http://blog.popstas.ru/blog/2017/02/26/apt-cacher-ng-for-testing-ansible-roles-with-docker-and-gitlab-ci/</link>
      <pubDate>Sun, 26 Feb 2017 04:14:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2017/02/26/apt-cacher-ng-for-testing-ansible-roles-with-docker-and-gitlab-ci/</guid>
      <description>&lt;p&gt;В &lt;a href=&#34;http://blog.popstas.ru/blog/2017/02/24/why-you-should-not-use-apt-mirror-for-ansible-tests-in-docker/&#34;&gt;предыдущей статье&lt;/a&gt; я настраивал &lt;code&gt;apt-mirror&lt;/code&gt; для тех же целей. У того способа нашлось несколько недостатков.&lt;/p&gt;

&lt;p&gt;В статье ниже описано, как решить ту же проблему, используя &lt;code&gt;apt-cacher-ng&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Tl;dr: на этот раз все получилось, этот способ меня устроил.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2017-02/apt-cacher-ng.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;настройка-apt-cacher-ng&#34;&gt;Настройка apt-cacher-ng&lt;/h2&gt;

&lt;p&gt;Здесь все довольно просто, проще, чем с &lt;code&gt;apt-mirror&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install apt-cacher-ng
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В конфиге я задал пароль админа в &lt;code&gt;/etc/apt-cacher-ng/security.conf&lt;/code&gt;, он дает право смотреть подробную статистику по cache-hit.&lt;/p&gt;

&lt;p&gt;В &lt;code&gt;/etc/apt-cacher-ng/acng.conf&lt;/code&gt; интересны следующие строчки:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExTreshold: 4&lt;/code&gt; - устаревание кеша, в днях. Если файл ни разу не запрашивался дольше указанного времени, он будет удален. Я увеличил до 30 дней&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PassThroughPattern: .*:443&lt;/code&gt; - нужно указать это, чтобы не было проблем с HTTPS репозиториями (об этом ниже).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В остальном стандартный конфиг делает следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;запускает веб-сервер для всего мира на &lt;code&gt;0.0.0.0:3142&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;хостит страничку и информацией о сервисе и статистикой на &lt;a href=&#34;http://myserver.ru:3142&#34; target=&#34;_blank&#34;&gt;http://myserver.ru:3142&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;хранит кеши в &lt;code&gt;/var/cache/apt-cacher-ng&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Также нужно отредактировать файл &lt;code&gt;/etc/apt-cacher-ng/backends_ubuntu&lt;/code&gt;, удалив из него лишние зеркала и поставив главное зеркало в начало, иначе рискуете однажды получить 403 ошибку при установке одного из пакетов (об этом чуть ниже). У меня файл такой:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://mirror.yandex.ru/ubuntu/
http://archive.ubuntu.com/ubuntu/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Подробности ремапинга можно почитать &lt;a href=&#34;https://www.unix-ag.uni-kl.de/~bloch/acng/html/config-serv.html&#34; target=&#34;_blank&#34;&gt;в документации&lt;/a&gt;. В 2 словах: когда клиент запрашивает пакет, apt-cacher-ng скачивает его не с репозитория, который прописан на клиенте, а с первого зеркала, указанного в файле ремапинга. Второй репозиторий по факту никогда не выбирается.&lt;/p&gt;

&lt;p&gt;После этого можно перезапустить сервис:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service apt-cacher-ng restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Проверяем, что он поднялся, должен открыться урл &lt;code&gt;http://myserver.ru:3142&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;ошибка-403-при-получении-одного-из-пакетов&#34;&gt;Ошибка 403 при получении одного из пакетов&lt;/h3&gt;

&lt;p&gt;Через некоторое время использования я споткнулся об ошибку:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install php-common -y
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  psmisc
The following NEW packages will be installed:
  php-common psmisc
0 upgraded, 2 newly installed, 0 to remove and 7 not upgraded.
Need to get 10.8 kB/58.8 kB of archives.
After this operation, 299 kB of additional disk space will be used.
Err:1 http://archive.ubuntu.com/ubuntu xenial/main amd64 php-common all 1:35ubuntu6
  403  Forbidden
E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/main/p/php-defaults/php-common_35ubuntu6_all.deb  403  Forbidden

E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Я стал разбираться, оказалось, что дело в прокси, если его убрать, все становится нормально.&lt;/p&gt;

&lt;p&gt;Оказалось, что репозиторий по умолчанию, который прописан в &lt;code&gt;/etc/apt-cacher-ng/backends_ubuntu.default&lt;/code&gt; какой-то немного битый и пакет php-common не отдавал. Чтобы этого не произошло, нужно добавить свои репозитории в &lt;code&gt;/etc/apt-cacher-ng/backends_ubuntu&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo http://archive.ubuntu.com/ubuntu/ &amp;gt; /etc/apt-cacher-ng/backends_ubuntu
service apt-cacher-ng restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ошибка-403-при-доступе-к-https-репозиториям&#34;&gt;Ошибка 403 при доступе к HTTPS репозиториям&lt;/h3&gt;

&lt;p&gt;В этом месте тоже появляются ошибки, проявляются в ошибках 403 при &lt;code&gt;apt-get update&lt;/code&gt;.
Проблема здесь в том, что apt-cacher-ng не может прочитать зашифрованный трафик от https репозиториев, но все равно пытается. Этого можно избежать двумя способами:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;добавить такие репозитории в исключения&lt;/li&gt;
&lt;li&gt;использовать http репозитории в sources, а потом ремапить их на настоящие репозитории в apt-cacher-ng&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый способ позволяет избежать изменения sources для системы-клиента apt-cacher-ng, второй - экономить трафик и для таких репозиториев. Я хочу, чтобы прокси работал максимально прозрачно, поэтому я использую первый способ. За то, какие репозитории обрабатывать, отвечает параметр &lt;code&gt;PassThroughPattern&lt;/code&gt;. Нам нужно исключить из регулярного выражения все HTTPS репозитории.&lt;/p&gt;

&lt;p&gt;Было:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PassThroughPattern: ^bugs.debian.org:443
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Стало:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PassThroughPattern: .*:443
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;О втором способе можно прочитать в &lt;a href=&#34;https://blog.packagecloud.io/eng/2015/05/05/using-apt-cacher-ng-with-ssl-tls/&#34; target=&#34;_blank&#34;&gt;этой статье&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;настройка-на-клиентах&#34;&gt;Настройка на клиентах&lt;/h2&gt;

&lt;p&gt;На клиентах нужно добавить один файлик с указанием адреса прокси, &lt;code&gt;sources.list&lt;/code&gt; менять не надо:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;Acquire::http::Proxy &amp;quot;http://myserver.ru:3142&amp;quot;;&#39; &amp;gt; /etc/apt/apt.conf.d/00aptproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На хосте я этого делать не стал, т.к. у меня там стоит старая Ubuntu 14.04, а тестирую я на Ubuntu 16.04. К слову, apt-cacher-ng это не волнует, он нормально кеширует новые пакеты, не смотря на то, что стоит на старой оси. Как я понимаю, его можно использовать и в смешанном режиме, то есть кешировать пакеты сразу от нескольких версий операционок, но я это не проверял.&lt;/p&gt;

&lt;p&gt;Вместо этого я положил файлик с указанием прокси в отдельную папку, откуда я буду пробрасывать его внутрь тестовых контейнеров:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;Acquire::http::Proxy &amp;quot;http://myserver.ru:3142&amp;quot;;&#39; &amp;gt; /usr/local/src/00aptproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;использование-с-molecule-gitlab-ci-и-travis-ci&#34;&gt;Использование с Molecule, Gitlab CI и Travis CI&lt;/h2&gt;

&lt;p&gt;Не знаю зачем, но роли я тестирую сразу двумя CI: Gitlab и Travis. В связи с этим появляется проблема: нужно на Gitlab CI использовать один кеширующий сервер, при локальном тестировании другой, а для Travis CI убирать его.&lt;/p&gt;

&lt;p&gt;Сложность в том, что Molecule не поддерживает разные конфиги, только умеет использовать в конфигах переменные окружения. Это я и использовал.&lt;/p&gt;

&lt;p&gt;Смысл в том, что на разных CI в контейнер будут пробрасываться разные &lt;code&gt;/etc/apt/apt.conf.d/00aptproxy&lt;/code&gt;, для Travis это будет просто пустой файл.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;script:
  - export MOLECULE_APTPROXY_PATH=&amp;quot;$PWD/00aptproxy&amp;quot;
  - touch &amp;quot;$MOLECULE_APTPROXY_PATH&amp;quot;
  - molecule --debug test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;molecule.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker:
  containers:
    - name: ansible-role-mysql
      image: ubuntu
      image_version: latest
      volume_mounts:
        - ${MOLECULE_APTPROXY_PATH}:/etc/apt/apt.conf.d/00aptproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.gitlab-ci.yml&lt;/code&gt; я решил не менять, вместо этого я изменил способ регистрации раннеров в Gitlab CI, используются специальные раннеры с проброшенной переменной окружения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gitlab-ci-multi-runner register -n \
  --executor docker \
  --description &amp;quot;Docker at myserver.ru on popstas/ubuntu-molecule&amp;quot; \
  --docker-image &amp;quot;popstas/ubuntu-molecule:latest&amp;quot; \
  --docker-volumes /var/run/docker.sock:/var/run/docker.sock \
  --env &amp;quot;MOLECULE_APTPROXY_PATH=/usr/local/src/00aptproxy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Это сделано потому, что я еще запускаю локальные раннеры, хотелось сделать так, чтобы &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; подходил во всех случаях.&lt;/p&gt;

&lt;p&gt;На локальной машине можно просто добавить переменные окружения через &lt;code&gt;export&lt;/code&gt; прямо в терминале или добавить их в ваш &lt;code&gt;~/.profile&lt;/code&gt;, тогда можно просто запускать &lt;code&gt;molecule test&lt;/code&gt; и все будет работать.&lt;/p&gt;

&lt;h2 id=&#34;тестирование-скорости&#34;&gt;Тестирование скорости&lt;/h2&gt;

&lt;p&gt;Дополню таблицу из &lt;a href=&#34;http://blog.popstas.ru/blog/2017/02/24/why-you-should-not-use-apt-mirror-for-ansible-tests-in-docker/&#34;&gt;прошлой статьи&lt;/a&gt;. Естественно, указано время второго прогона apt-cacher-ng для роли, т.к. в первый запуск пакеты еще не скачались, и скорость будет как при использовании стандартного репозитория.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Роль&lt;/th&gt;
&lt;th&gt;archive.ubuntu.org&lt;/th&gt;
&lt;th&gt;apt-mirror&lt;/th&gt;
&lt;th&gt;apt-cacher-ng&lt;/th&gt;
&lt;th&gt;Travis CI:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ansible-role-common&lt;/td&gt;
&lt;td&gt;8:04&lt;/td&gt;
&lt;td&gt;6:18&lt;/td&gt;
&lt;td&gt;6:30&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4:32&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-mysql&lt;/td&gt;
&lt;td&gt;3:41&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;3:22&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3:26&lt;/td&gt;
&lt;td&gt;3:46&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-zsh&lt;/td&gt;
&lt;td&gt;3:16&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2:54&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2:56&lt;/td&gt;
&lt;td&gt;4:08&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Как видим, в скорости решение с &lt;code&gt;apt-cacher-ng&lt;/code&gt; по сравнению с &lt;code&gt;apt-mirror&lt;/code&gt; почти не теряет. Если не видно разницы, зачем тратить лишние 140 Гб?&lt;/p&gt;

&lt;p&gt;Кстати, скорость тестирования увеличилась и на других способах, которые я описывал в прошлой статье: если тогда разница между способами была 20-30%, то теперь она сократилась до 10-20%. Это говорит о том, что если ничего не делать и пользоваться стандартными удаленными репозиториями, вы будете больше зависеть от внешних факторов.&lt;/p&gt;

&lt;h2 id=&#34;выводы&#34;&gt;Выводы&lt;/h2&gt;

&lt;h3 id=&#34;минусы&#34;&gt;Минусы:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Подходит только для множественного запуска однотипных установок, в моем случае так и есть&lt;/li&gt;
&lt;li&gt;Немного медленнее, чем при использовании зеркала, минусом это назвать сложно, т.к. разница всего 1-3%&lt;/li&gt;
&lt;li&gt;Нужно пробрасывать порт через фаервол, если хотите открыть прокси всему миру, я этого делать не стал :)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;плюсы&#34;&gt;Плюсы:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Хранит только нужные пакеты&lt;/li&gt;
&lt;li&gt;Кеширует не только пакеты из стандартного репозитория, но и внешние пакеты, которые вы добавляете в &lt;code&gt;sources.list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Не требует изменения sources.list&lt;/li&gt;
&lt;li&gt;Проше настраивать&lt;/li&gt;
&lt;li&gt;Не нужен веб-сервер (nginx)&lt;/li&gt;
&lt;li&gt;По умолчанию фаервол закрывает вас&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как видите, минусы надуманны, а плюсы реальны. На этом история ускорения скачивания пакетов закончена, но остается еще много интересных моментов в тестировании Ansible на Gitlab CI, продолжение следует.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Как я создал и отказался от локального репозитория apt-mirror для Ubuntu для ускорения тестирования ansible ролей</title>
      <link>http://blog.popstas.ru/blog/2017/02/24/why-you-should-not-use-apt-mirror-for-ansible-tests-in-docker/</link>
      <pubDate>Fri, 24 Feb 2017 17:39:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2017/02/24/why-you-should-not-use-apt-mirror-for-ansible-tests-in-docker/</guid>
      <description>&lt;p&gt;При тестировании плейбуков на чистой Ubuntu (а как же еще?) самые большие накладные расходы по времени (субъективно)
и уж точно самые большие по трафику уходят на установку пакетов из системного репозитория. Особенно это заметно, когда видишь, что один и тот же тест Travis CI прогоняет в 1.5 раза быстрее.&lt;/p&gt;

&lt;p&gt;Ниже описано, как создать зеркало из &lt;a href=&#34;http://mirror.yandex.ru/ubuntu&#34; target=&#34;_blank&#34;&gt;http://mirror.yandex.ru/ubuntu&lt;/a&gt; и подружить его с Gitlab CI и molecule.&lt;/p&gt;

&lt;p&gt;Tl;dr: не делайте локальный репозиторий через &lt;code&gt;apt-mirror&lt;/code&gt; для мелких задач, не стоит оно того. Вместо этого нужно поднять кеширующий сервер через &lt;a href=&#34;http://blog.popstas.ru/blog/2017/02/26/apt-cacher-ng-for-testing-ansible-roles-with-docker-and-gitlab-ci/&#34;&gt;apt-cacher-ng&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2017-02/apt-mirror.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;настройка-apt-mirror&#34;&gt;Настройка apt-mirror&lt;/h2&gt;

&lt;p&gt;Для синхронизации локального репозитория с основным вариант один - &lt;code&gt;apt-mirror&lt;/code&gt;.
&lt;a href=&#34;https://apt-mirror.github.io&#34; target=&#34;_blank&#34;&gt;Официальный сайт&lt;/a&gt; считает нас умными, поэтому все его инструкции заключаются в 3 строчках:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;apt-get install apt-mirror
nano /etc/apt/mirror.list
sudo apt-mirror
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Все действительно почти так просто. Почти.&lt;/p&gt;

&lt;h3 id=&#34;выбор-самого-быстрого-репозитория&#34;&gt;Выбор самого быстрого репозитория&lt;/h3&gt;

&lt;p&gt;Пока гуглил тему, случайно наткнулся на &lt;a href=&#34;https://hub.docker.com/r/evgeniyklemin/ubuntu-fastest-apt-mirror/&#34; target=&#34;_blank&#34;&gt;инструкцию&lt;/a&gt;, как выбрать самый быстрый репозиторий.
Скорее всего, для нас для всех это будет &lt;a href=&#34;http://mirror.yandex.ru/ubuntu&#34; target=&#34;_blank&#34;&gt;http://mirror.yandex.ru/ubuntu&lt;/a&gt;, но можно в этом убедиться:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;wget -q -nv -O- http://ftp.ru.debian.org/debian/pool/main/n/netselect/netselect_0.3.ds1-26_amd64.deb &amp;gt; /tmp/netselect_0.3.ds1-26_amd64.deb
dpkg -i /tmp/netselect_0.3.ds1-26_amd64.deb
netselect -s3 -t20 &lt;span style=&#34;color: #586E75&#34;&gt;`&lt;/span&gt;wget -q -nv -O- https://launchpad.net/ubuntu/+archivemirrors &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; grep -P -B8 &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;statusUP|statusSIX&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; grep -o -P &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;(f|ht)tp.*\&amp;quot;&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; tr &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;&amp;quot;\n&amp;#39;&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;  &amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #586E75&#34;&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Пакета нет в репозитории Ubuntu, поэтому качаем из репозитория Debian
В результате вы получите список из 3 самых быстрых (по пингу) репозиториев:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;54 http://mirror.yandex.ru/ubuntu/
89 http://ubuntu.volia.net/ubuntu-archive/
124 http://nl.archive.ubuntu.com/ubuntu/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;конфигурация&#34;&gt;Конфигурация&lt;/h3&gt;

&lt;p&gt;Открываем &lt;code&gt;/etc/apt/mirror.list&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Меняем &lt;code&gt;archive.ubuntu.com&lt;/code&gt; на &lt;code&gt;mirror.yandex.ru&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Убираем &lt;code&gt;multiverse&lt;/code&gt; репозиторий (в стандартном Docker контейнере &lt;code&gt;ubuntu&lt;/code&gt; его нет, видимо не очень нужен, зато экономим сразу 13 Гб).&lt;/li&gt;
&lt;li&gt;Меняем путь хранения зеркала, не забывая после этого скопировать пустой скрипт в новое место &lt;code&gt;/var/spool/apt-mirror/var/postmirror.sh&lt;/code&gt;, иначе &lt;code&gt;apt-mirror&lt;/code&gt; будет в конце падать с ошибкой. У меня зеркало будет храниться в &lt;code&gt;/var/backups/apt-mirror&lt;/code&gt; (на диске с бекапами места много)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это же в виде команд:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;sed -i /etc/apt/mirror.list &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;s/archive.ubuntu.com/mirror.yandex.ru/g&amp;#39;&lt;/span&gt;
sed -i /etc/apt/mirror.list &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;s/ multiverse//g&amp;#39;&lt;/span&gt;
sed -i /etc/apt/mirror.list &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;s/\/var\/spool\/apt-mirror/\var\/backups\/apt-mirror/g&amp;#39;&lt;/span&gt;
mkdir -p /var/backups/apt-mirror/var
cp /var/spool/apt-mirror/var/postmirror.sh /var/backups/apt-mirror/var
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Добавляем в cron задание по обновлению репозитория, я буду запускать в 1 ночи:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;sed -i &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;#39;s/#0 4/0 1/g&amp;#39;&lt;/span&gt; /etc/cron.d/apt-mirror
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Настраиваем nginx на отдачу репозитория, у меня конфиг такой:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;server &lt;span style=&#34;color: #719e07&#34;&gt;{&lt;/span&gt;
  listen &lt;span style=&#34;color: #2AA198&#34;&gt;80&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt;
  server_name mirror.myserver.ru&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt;
  root /var/backups/apt-mirror/mirror/mirror.yandex.ru&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt;
  access_log off&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt;

  location / &lt;span style=&#34;color: #719e07&#34;&gt;{&lt;/span&gt;
    autoindex on&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color: #719e07&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #719e07&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Все готово, осталось запустить &lt;code&gt;apt-mirror&lt;/code&gt; и подождать денек: у меня выкачивалось 142 Гб.
Причем обновления тоже будут весить ощутимо, как я понял: через день я запустил apt-mirror еще раз,
он скачал 1.5 Гб.&lt;/p&gt;

&lt;p&gt;Проверяем URL &lt;a href=&#34;http://mirror.myserver.ru/&#34; target=&#34;_blank&#34;&gt;http://mirror.myserver.ru/&lt;/a&gt;, там должен быть доступен каталог &lt;code&gt;ubuntu&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;После этого можете сменить системные репозитории в ваших локальных убунтах и наслаждаться скоростью.&lt;/p&gt;

&lt;p&gt;date = &amp;ldquo;Ошибка&amp;rdquo;
slug = &amp;ldquo;Ошибка/why-you-should-not-use-apt-mirror-for-ansible-tests-in-docker&amp;rdquo;
Хотя нет, насладиться сразу конечно не получилось. По какой-то причине (наверное причина в месте на диске), apt-mirror выкачивает только amd64 пакеты, из-за чего &lt;code&gt;apt-get update&lt;/code&gt; ругается:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W: The repository &#39;http://apt.myserver.ru/ubuntu xenial-backports Release&#39; does not have a Release file.
W: Failed to fetch http://apt.myserver.ru/ubuntu/dists/xenial/main/binary-i386/Packages: 404  Not Found
W: Failed to fetch http://apt.myserver.ru/ubuntu/dists/xenial-updates/main/binary-i386/Packages: 404  Not Found
E: Some index files failed to download. They have been ignored, or old ones used instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Казалось бы ничего страшного, но уверен, что в тестах ненулевой код выхода apt-get будет все останавливать, поэтому придется чинить.&lt;/p&gt;

&lt;p&gt;Ошибка есть на &lt;a href=&#34;https://askubuntu.com/questions/465303/apt-mirror-error/574141&#34; target=&#34;_blank&#34;&gt;askubuntu.com&lt;/a&gt;, спасибо человеку, который предложил решение и негодовал по поводу того, что есть только в &lt;code&gt;man sources.list&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Решение напрашивается: явно указывать в &lt;code&gt;sources.list&lt;/code&gt;, что в репозитории только amd64 пакеты, то есть вместо:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb [ arch=amd64 ] http://apt.myserver.ru/ubuntu/ xenial main restricted universe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;С настройкой &lt;code&gt;apt-mirror&lt;/code&gt; закончили, перейдем к использованию в тестах.&lt;/p&gt;

&lt;h2 id=&#34;переключение-docker-контейнера-на-локальный-apt-репозиторий&#34;&gt;Переключение Docker контейнера на локальный apt репозиторий&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ekino/docker-images/tree/master/apt-mirror&#34; target=&#34;_blank&#34;&gt;https://github.com/ekino/docker-images/tree/master/apt-mirror&lt;/a&gt; - здесь приведено 2 способа настройки репозитория в контейнере, не изменяя его:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;[Плохой способ] Подмена через DNS&lt;/li&gt;
&lt;li&gt;[Хороший способ] Подмена &lt;code&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Я выбрал хороший. Делается это монтированием файла на место &lt;code&gt;/etc/apt/sources.list&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;FQDN&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;apt.myserver.ru&amp;quot;&lt;/span&gt;
cat &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;lt;&amp;lt;EOF &amp;gt; sources.list-$FQDN&lt;/span&gt;
&lt;span style=&#34;color: #2AA198&#34;&gt;deb [ arch=amd64 ] http://$FQDN/ubuntu/ xenial main restricted universe&lt;/span&gt;
&lt;span style=&#34;color: #2AA198&#34;&gt;deb [ arch=amd64 ] http://$FQDN/ubuntu/ xenial-updates main restricted universe&lt;/span&gt;
&lt;span style=&#34;color: #2AA198&#34;&gt;deb [ arch=amd64 ] http://$FQDN/ubuntu/ xenial-security main restricted universe&lt;/span&gt;
&lt;span style=&#34;color: #2AA198&#34;&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Чтобы не тащить с собой артефакты, файл создается командой.&lt;/p&gt;

&lt;p&gt;После этого проверяем, это должно отработать нормально:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;docker run --rm -it -v &lt;span style=&#34;color: #719e07&#34;&gt;$(&lt;/span&gt;readlink -f sources.list-&lt;span style=&#34;color: #268BD2&#34;&gt;$FQDN&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;)&lt;/span&gt;:/etc/apt/sources.list ubuntu:16.04 apt-get update
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Если &lt;code&gt;readlink&lt;/code&gt; выдает ошибку &lt;code&gt;readlink: illegal option -- f&lt;/code&gt;, тогда вы скорее всего сидите на MacOS и вам нужно сделать &lt;code&gt;brew install coreutils&lt;/code&gt; и прописать в переменную &lt;code&gt;PATH&lt;/code&gt; то, что он просит.&lt;/p&gt;

&lt;h2 id=&#34;сравнение-скорости&#34;&gt;Сравнение скорости&lt;/h2&gt;

&lt;p&gt;Я потратил около 4 часов на то, чтобы настроить локальные репозитории, посмотрим, сколько я сэкономил времени.
Скорость инета у меня 30 мбит.&lt;/p&gt;

&lt;p&gt;Я сравнил отработку &lt;code&gt;time molecule test&lt;/code&gt; на 3 ansible ролях, вот результаты:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Роль&lt;/th&gt;
&lt;th&gt;Стандартный репозиторий&lt;/th&gt;
&lt;th&gt;Локальный репозиторий&lt;/th&gt;
&lt;th&gt;Travis CI:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ansible-role-common&lt;/td&gt;
&lt;td&gt;8:04&lt;/td&gt;
&lt;td&gt;6:18&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4:32&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-mysql&lt;/td&gt;
&lt;td&gt;3:41&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;3:22&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3:46&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-zsh&lt;/td&gt;
&lt;td&gt;3:29&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2:54&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4:08&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Как видно, прирост небольшой, всего 20-30%.
UPD 26.02.2017: на при написании &lt;a href=&#34;http://blog.popstas.ru/blog/2017/02/26/apt-cacher-ng-for-testing-ansible-roles-with-docker-and-gitlab-ci/&#34;&gt;статьи про apt-cacher-ng&lt;/a&gt; я перепроверил результаты и разница сократилась до 10-20%.&lt;/p&gt;

&lt;p&gt;Тут надо заметить, что в &lt;code&gt;test&lt;/code&gt; входит проверка идемпотентности, где никакие пакеты не ставятся. Тогда я сравнил время выполнения &amp;lsquo;molecule converge&amp;rsquo; для &lt;code&gt;ansible-role-mysql&lt;/code&gt; и получил немного лучшие результаты: 2:30 против 3:17, это уже почти в 2 раза быстрее.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Роль&lt;/th&gt;
&lt;th&gt;Стандартный репозиторий&lt;/th&gt;
&lt;th&gt;Локальный репозиторий&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ansible-role-common&lt;/td&gt;
&lt;td&gt;8:15&lt;/td&gt;
&lt;td&gt;6:09&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-mysql&lt;/td&gt;
&lt;td&gt;3:17&lt;/td&gt;
&lt;td&gt;2:30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ansible-role-zsh&lt;/td&gt;
&lt;td&gt;4:05&lt;/td&gt;
&lt;td&gt;2:43&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;выводы-по-поводу-apt-mirror&#34;&gt;Выводы по поводу apt-mirror&lt;/h2&gt;

&lt;p&gt;Результаты меня немного расстроили. Оказалось, что поразительного прироста в скорости, на который я надеялся, не будет.&lt;/p&gt;

&lt;h3 id=&#34;плюсы&#34;&gt;Плюсы:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;один раз потратил время, чтобы при каждом тесте ждать меньше&lt;/li&gt;
&lt;li&gt;уменьшает желание тестировать не на чистой машине&lt;/li&gt;
&lt;li&gt;интернет-канал не занимается в рабочее время&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;минусы&#34;&gt;Минусы&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;эффект слабый, 20-30%&lt;/li&gt;
&lt;li&gt;сложности с пробросом файла &lt;code&gt;sources.list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;уход от стандартной конфигурации Gitlab CI&lt;/li&gt;
&lt;li&gt;разные конфиги для Travis CI и Gitlab CI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;На основе этого сделал для себя вывод: это подходит только для локального постоянного применения, в остальных случаях минусы перевешивают.&lt;/p&gt;

&lt;h2 id=&#34;что-то-тут-не-так&#34;&gt;Что-то тут не так&amp;hellip;&lt;/h2&gt;

&lt;p&gt;После этого я задумался: а как делают &amp;ldquo;большие&amp;rdquo;? Из серьезных решений для локальных репозиториев я знаю только Artifactory. Пошел посмотреть, как у них обстоят дела с зеркалами и &lt;a href=&#34;https://www.jfrog.com/knowledge-base/how-to-mirror-a-remote-repository/&#34; target=&#34;_blank&#34;&gt;нашел&lt;/a&gt;: они умеют быть зеркалом, но не рекоменуют их так использовать, т.к. это неэффективно. Вместо этого они предлагают пользоваться ими как кеширующим сервером. Такие дела&amp;hellip;&lt;/p&gt;

&lt;p&gt;UPD 26.02.2017: перешел на использование apt-cacher-ng, в моем случае он лучше по всем параметрам, подробности читайте в продолжении&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Извлечение одной из папок в git репозитории в отдельный репозиторий с сохранением истории - git-extract-subproject</title>
      <link>http://blog.popstas.ru/blog/2017/02/22/2017/02/22/git-extract-subproject-preserving-history/</link>
      <pubDate>Wed, 22 Feb 2017 01:19:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2017/02/22/2017/02/22/git-extract-subproject-preserving-history/</guid>
      <description>&lt;p&gt;Занялся я тут распиливанием большого проекта (дерево ansible ролей) на отдельные репозитории.&lt;/p&gt;

&lt;h3 id=&#34;для-этого-надо&#34;&gt;Для этого надо:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Извлечь директорию подпроекта в отдельный репозиторий&lt;/li&gt;
&lt;li&gt;Удалить из проекта папку подпроекта&lt;/li&gt;
&lt;li&gt;Добавить в большой проект зависимость от подпроекта&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ниже написано, как сделать 1-й шаг одной командой через скрипт &lt;code&gt;git-extract-subproject&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2017-02/git-extract-subproject.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;В общем все оказалось просто, за минуту находится статья об этом - &lt;a href=&#34;http://gbayer.com/development/moving-files-from-one-git-repository-to-another-preserving-history/&#34; target=&#34;_blank&#34;&gt;
Moving Files from one Git Repository to Another, Preserving History&lt;/a&gt;, за 10 минут становится понятно, что как работает.&lt;/p&gt;

&lt;p&gt;Мне нужно было проделать эту операцию 10+ раз, поэтому написал скрипт, извлекающий репозиторий одной командой.&lt;/p&gt;

&lt;h2 id=&#34;алгоритм-извлечения&#34;&gt;Алгоритм извлечения:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Клонировать большой проект во временный репозиторий&lt;/li&gt;
&lt;li&gt;Удалить из него все, кроме папки модуля через git-фильтр. При этом переписывается история&lt;/li&gt;
&lt;li&gt;Создать чистый репозиторий для нового модуля&lt;/li&gt;
&lt;li&gt;Добавить в чистый репозиторий временный, как remote source&lt;/li&gt;
&lt;li&gt;Сделать pull из remote source в master&lt;/li&gt;
&lt;li&gt;Подчистить следы&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;По идее уже после п.2 временный репозиторий выглядит как готовый модуль, пп.3-6 нужны для того, чтобы не тащить следы истории и настроек родительского проекта в дочерний.&lt;/p&gt;

&lt;p&gt;Например, у меня есть репозиторий &lt;code&gt;ansible-server&lt;/code&gt;, в нем лежит роль &lt;code&gt;roles/server-scripts&lt;/code&gt;. Тогда нужно перейти в папку ansible-server и запустить:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git-extract-subproject roles/server-scripts ansible-role-server-scripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого рядом с &lt;code&gt;ansible-server&lt;/code&gt; создастся готовый проект &lt;code&gt;ansible-role-server-scripts&lt;/code&gt;. Остается добавить в него remote origin куда следует и запушить.&lt;/p&gt;

&lt;p&gt;В итоге получился репозиторий с историей - &lt;a href=&#34;https://github.com/viasite-ansible/ansible-role-server-scripts/commits/master&#34; target=&#34;_blank&#34;&gt;viasite-ansible/ansible-role-server-scripts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Код скрипта здесь - &lt;a href=&#34;https://github.com/popstas/server-scripts/blob/master/bin/git-extract-subproject&#34; target=&#34;_blank&#34;&gt;popstas/server-scripts&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kapacitor: часть 1. Введение, сравнение с Monit, установка с Ansible и без, настройка</title>
      <link>http://blog.popstas.ru/blog/2016/05/19/kapacitor-ansible-install-monit-comparsion/</link>
      <pubDate>Thu, 19 May 2016 00:47:52 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/05/19/kapacitor-ansible-install-monit-comparsion/</guid>
      <description>&lt;p&gt;Несколько недель назад я начал разбираться с Kapacitor, попутно записывая свои действия. Конца разбирательствам было не видно, записей становилось все больше и накопилось на серию.&lt;/p&gt;

&lt;p&gt;Речь пойдет о Kapacitor, последнеем слое из стека &lt;a href=&#34;https://influxdata.com/get-started/what-is-the-tick-stack/&#34; target=&#34;_blank&#34;&gt;TICK&lt;/a&gt; от InfluxData, набора программ для сбора, отображения и обработке метрик.&lt;/p&gt;

&lt;p&gt;Tl;dr: думаю, что Kapacitor нужен только тем, кто уже использует InfluxDB для сбора метрик. С установкой могут быть проблемы, если руки кривые.&lt;/p&gt;

&lt;p&gt;А также небольшое замечание о том, &lt;a href=&#34;http://blog.popstas.ru/blog/2016/05/19/kapacitor-ansible-install-monit-comparsion/#github-pull-request&#34;&gt;как делать Pull request&amp;rsquo;ы из браузера за 2 минуты&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;background:#1F242D&#34; src=&#34;http://blog.popstas.ru/images/2016-05/kapacitor.svg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Я уже настроил три слоя из стека: на серверах стоят агенты Telegraf, передают метрики в InfluxDB, их можно смотреть в виде графиков через Grafana (InfluxData предлагает свой Chronograf, но он сильно отстает от Grafana по функционалу на январь 2016 и вряд ли это изменится).&lt;/p&gt;

&lt;p&gt;У этой схемы есть недостаток: чтобы узнать, что что-то идет не так, нужно зайти в Grafana и глазами найти это что-то. Это меня устраивает, когда я уже знаю, что сервер плохо себя чувствует.&lt;/p&gt;

&lt;p&gt;Kapacitor нужен для уведомлений, алертинга. В 2 словах: это демон, который умеет пропускать через себя данные, приходящие в InfluxDB, обрабатывать их и пересылать по разным каналам связи / на HTTP / в базу данных.&lt;/p&gt;

&lt;p&gt;Для меня Kapacitor - прямой конкурент Monit, поэтому сравниваю с ним, больше ни с чем подобным дел не имел, но слышал, что для мониторинга серверов правильные пацаны используют Zabbix, Nagios/Icinga, Sensu, Riemann. Я решил пока не добавлять софта на сервера, да и уведомлять на основе уже собранных данных мне кажется правильным, этим объясняется мой выбор в пользу Kapacitor.&lt;/p&gt;

&lt;h3 id=&#34;плюсы-kapacitor&#34;&gt;Плюсы Kapacitor&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Убирание лишнего. Kapacitor не надо ставить агентом, роль агента выполняет Telegraf. Monit, которым я пользуюсь сейчас для алертинга, дублирует функционал, собирая метрики самостоятельно.&lt;/li&gt;
&lt;li&gt;Надежный алертинг. У monit тут есть проблема: когда умирает сервер, monit, установленный там, тоже умирает и не успевает отправить алерт на email. Надежный, кроме случаев, когда падает Kapacitor или InfluxDB, что случается.&lt;/li&gt;
&lt;li&gt;Продвинутый алертинг. Monit умеет мало (ладно, много, но я умею на нем мало). Kapacitor имеет в распоряжении данные всех моих серверов, что позволяет ему смотреть на них как на систему. У меня в этом месте фантазия начинает играть, не буду расписывать, что по моему мнению можно отслеживать через Kapacitor, так как может такого и нельзя :)&lt;/li&gt;
&lt;li&gt;Каналы алертинга. Заявлена поддержка HipChat, OpsGenie, Alerta, Sensu, PagerDuty, Slack, VictorOps, кроме этого есть запись в лог, email, POST-запрос. Для разных событий можно указывать разные каналы. Monit умеет только email, а мне нужен был Slack.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;плюсы-monit&#34;&gt;Плюсы Monit:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Monit проверенный, а Kapacitor - нет, как и весь TICK.&lt;/li&gt;
&lt;li&gt;Monit имеет прямой доступ к серверу, что позволяет ему реагировать самостоятельно, например, перезагружать сервис, если он не отвечает. Kapacitor умеет только уведомлять.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;установка&#34;&gt;Установка&lt;/h2&gt;

&lt;p&gt;Ставить можно &lt;a href=&#34;https://influxdata.com/downloads/#kapacitor&#34; target=&#34;_blank&#34;&gt;по-разному&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Для тех, кто не дружит с Ansible, установка из репозитория, &lt;a href=&#34;https://docs.influxdata.com/influxdb/v0.13/introduction/installation/&#34; target=&#34;_blank&#34;&gt;взятая из мануала&lt;/a&gt; по InfluxDB (репозиторий один на весь стек InfluxData):&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;curl -sL https://repos.influxdata.com/influxdb.key &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; sudo apt-key add -
&lt;span style=&#34;color: #B58900&#34;&gt;source&lt;/span&gt; /etc/lsb-release
&lt;span style=&#34;color: #B58900&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;deb https://repos.influxdata.com/${&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;DISTRIB_ID&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;,,&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;} ${&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;DISTRIB_CODENAME&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;} stable&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; sudo tee /etc/apt/sources.list.d/influxdb.list
aptitude update
aptitude install kapacitor
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Я буду ставить через Ansible &lt;a href=&#34;https://github.com/rossmcdonald/kapacitor&#34; target=&#34;_blank&#34;&gt;rossmcdonald/kapacitor&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;ansible-galaxy install rossmcdonald.kapacitor
ansible-playbook -c &lt;span style=&#34;color: #B58900&#34;&gt;local&lt;/span&gt; kapacitor.yml
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&#34;a-name-github-pull-request-a-как-просто-делать-pull-request&#34;&gt;&lt;a name=&#34;github-pull-request&#34;&gt;&lt;/a&gt;Как просто делать Pull request&lt;/h4&gt;

&lt;p&gt;В плейбуке была ошибка, я бы об этом не упоминал, если бы не узнал недавно, как просто &lt;a href=&#34;https://github.com/rossmcdonald/kapacitor/pull/1&#34; target=&#34;_blank&#34;&gt;делать pull request&lt;/a&gt; прямо в браузере. Это заняло минуты две: жмем &amp;ldquo;редактировать&amp;rdquo; на интересующем файле, правим, ниже пишем сообщение к коммиту, сохраняем. Это автоматом создаст форк, отдельную ветку и сделает туда коммит. На следующей странице останется нажать &amp;ldquo;Create pull request&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;настройка&#34;&gt;Настройка&lt;/h2&gt;

&lt;p&gt;Так как я уже использовал готовую ansible-роль, настройка уже включена в установку. Я взял &lt;a href=&#34;https://github.com/rossmcdonald/kapacitor/blob/master/test.yml&#34; target=&#34;_blank&#34;&gt;тестовый плейбук&lt;/a&gt; роли и изменил его: добавил данные авторизации в InfluxDB, SMTP, Slack. Опция &lt;code&gt;global&lt;/code&gt; в настройках канала для уведомлений означает, что он будет использоваться по умолчанию в скриптах, иначе его нужно указывать явно.&lt;/p&gt;

&lt;p&gt;Для установки сделал такой плейбук:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;hosts:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;all&lt;/span&gt;
  &lt;span style=&#34;color: #93A1A1&#34;&gt;roles:&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;role:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;rossmcdonald.kapacitor&lt;/span&gt;
  &lt;span style=&#34;color: #93A1A1&#34;&gt;vars:&lt;/span&gt;
    &lt;span style=&#34;color: #586E75&#34;&gt;# [influxdb]&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_influxdb_enabled:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_influxdb_urls:&lt;/span&gt;
      &lt;span style=&#34;color: #93A1A1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;http://localhost:8086&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_influxdb_username:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;user&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_influxdb_password:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;pass&lt;/span&gt;

    &lt;span style=&#34;color: #586E75&#34;&gt;# [smtp]&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_enabled:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_host:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;smtp.yandex.ru&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_port:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;587&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_username:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;example@yandex.ru&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_password:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;pass&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_from:&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;example@yandex.ru&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_smtp_to:&lt;/span&gt;
      &lt;span style=&#34;color: #93A1A1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;admin@example.com&amp;quot;&lt;/span&gt;

    &lt;span style=&#34;color: #586E75&#34;&gt;# [slack]&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_slack_enabled:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_slack_url:&lt;/span&gt;  &lt;span style=&#34;color: #93A1A1&#34;&gt;https://hooks.slack.com/services/G2JFW7VFQ/B13UHEN5X/9J6IVIcUw9FGCeF7hfjFNGBn&lt;/span&gt; &lt;span style=&#34;color: #586E75&#34;&gt;# url ненастоящий&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_slack_channel:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;#servers&amp;quot;&lt;/span&gt;
    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_slack_global:&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;

    &lt;span style=&#34;color: #93A1A1&#34;&gt;kapacitor_tasks_to_enable:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;проверка&#34;&gt;Проверка&lt;/h2&gt;

&lt;p&gt;Лучший способ проверить, что Kapacitor видит данные из InfluxDB - записать фрагмент:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;kapacitor record stream -name la_alert -duration 5s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Если запись пошла, можно приступать к самому интересному: созданию алертов.&lt;/p&gt;

&lt;p&gt;Если через 5 секунд команда не завершилась, значит что-то пошло не так.
Смотрим логи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kapacitor может говорить об ошибках к подключению к InfluxDB&lt;/li&gt;
&lt;li&gt;InfluxDB может сыпать &lt;code&gt;connection refused&lt;/code&gt; ошибками&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В моем случае домен, который я прописал в конфиге Kapacitor, был прописан в /etc/hosts на 127.0.1.1, Kapacitor слушал этот порт, соответственно, InfluxDB не мог достучаться из Docker-контейнера.&lt;/p&gt;

&lt;h4 id=&#34;проблема-из-за-docker&#34;&gt;Проблема из-за Docker&lt;/h4&gt;

&lt;p&gt;У меня в логах была ошибка:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open server: open service *influxdb.Service: subscription already exists
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Я указал другой локальный хост, localhost, т.к. я не предполагаю, что к kapacitor будет обращаться кто-то, кроме InfluxDB, который стоит на той же машине. Это не помогло. Я не понял, в чем ошибка, nmap показывает свободный порт. Оставил стандартный, поддомен машины, это почему-то сработало.&lt;/p&gt;

&lt;p&gt;Оказалось, проблема была в том, что InfluxDB при первом запуске Kapacitor&amp;rsquo;а создал на него подписки (subscriptions), которые означают то, что InfluxDB будет пересылать в Kapacitor все, что приходит в него.&lt;/p&gt;

&lt;p&gt;InfluxDB у меня крутится в Docker&amp;rsquo;е с проброшенными портами, а Kapacitor - нет, то есть они технически были не на одной машине. Точнее, для Kapacitor&amp;rsquo;а казалось, что InfluxDB на этой же машине, но для Influx&amp;rsquo;a он на другой машине! Оказалось, что изнутри докера внутренний адрес, на который создались подписки, вел не туда, поэтому данные не доходили до Kapacitor, чтобы исправить это, понадобилось удалить подписки, узнав их имена:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;SHOW&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;SUBSCRIPTIONS&lt;/span&gt;
&lt;span style=&#34;color: #719e07&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;SUBSCRIPTION&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;kapacitor-42d050d7-5e60-462f-b079-3f8157ec2eff&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;telegraf&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #719e07&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color: #93A1A1&#34;&gt;SUBSCRIPTION&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;kapacitor-42d050d7-5e60-462f-b079-3f8157ec2eff&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;_internal&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;monitor&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;выводы&#34;&gt;Выводы&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Использование Docker для InfluxDB сильно усложнило мне процесс установки при том, что ничего мне не дало: InfluxDB - это один бинарник, если у вас вся инфраструктура живет не в контейнерах, используйте установку из репозиториев, это проще. С другой стороны откатиться на предыдущую версию будет сложнее&amp;hellip;&lt;/li&gt;
&lt;li&gt;Kapacitor сильно превосходит Monit по возможностям алертинга, но уступает ему в контроле над ситуацией. Хотя можно себе представить сценарий, что Kapacitor отправляет POST-запрос с инструкциями к действиям сервису, который делает что-то, но меня такой самопальный RPC пугает.&lt;/li&gt;
&lt;li&gt;Все это достаточно сырое в том смысле, что нет достаточной обвязки (оф. &lt;a href=&#34;https://hub.docker.com/r/library/influxdb/&#34; target=&#34;_blank&#34;&gt;контейнер для InfluxDB&lt;/a&gt; появился только 16 мая, самый популярный плейбук для Kapacitor понадобилось править, чтобы установить), информации очень мало, кроме GitHub issues и документации на данный момент нет ничего. Поэтому появляющиеся проблемы решать будет сложнее.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ссылки&#34;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdata.com/time-series-platform/kapacitor/&#34; target=&#34;_blank&#34;&gt;страница Kapacitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdata.com/get-started/configuring-alerts-with-kapacitor/&#34; target=&#34;_blank&#34;&gt;оф. туториал&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.influxdata.com/kapacitor/v0.12/&#34; target=&#34;_blank&#34;&gt;docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/influxdata/kapacitor&#34; target=&#34;_blank&#34;&gt;influxdata/kapacitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/influxdata/kapacitor-docker&#34; target=&#34;_blank&#34;&gt;influxdata/kapacitor-docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rossmcdonald/kapacitor&#34; target=&#34;_blank&#34;&gt;ansible-role-kapacitor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Bash on Ubuntu on Windows: первый блин</title>
      <link>http://blog.popstas.ru/blog/2016/04/11/bash-on-ubuntu-on-windows/</link>
      <pubDate>Mon, 11 Apr 2016 05:01:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/04/11/bash-on-ubuntu-on-windows/</guid>
      <description>

&lt;p&gt;Итак, &lt;a href=&#34;http://blog.popstas.ru/blog/2016/04/07/windows-ubuntu-bash-insider-update-not-available/&#34;&gt;дождался обновления&lt;/a&gt; Windows, поставил в нее Ubuntu &lt;a href=&#34;http://blog.zacorp.ru/main/kak-vklyuchit-podderzhku-ubuntu-v-windows-10/&#34; target=&#34;_blank&#34;&gt;по инструкции&lt;/a&gt;, вот что было дальше:&lt;/p&gt;

&lt;p&gt;Tl;dr: оно очень сырое, не работает почти ничего.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-04/windows-ubuntu-bash.png&#34; /&gt;&lt;/p&gt;

&lt;!--more --&gt;

&lt;p&gt;Первым делом захотелось родной zsh, берем aptitude, ставим, Ubuntu же!
Шелл открылся под root, так что sudo не нужен.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aptitude install zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конечно, ничего не вышло :) Во-первых, aptitude не нашел файл /var/lock/aptitude,
нет проблем, ставим через &lt;code&gt;apt-get&lt;/code&gt;, но оказывается, что нет инета.&lt;/p&gt;

&lt;p&gt;Про это есть &lt;a href=&#34;https://github.com/Microsoft/CommandLine-Documentation/issues/14&#34; target=&#34;_blank&#34;&gt;issue#14&lt;/a&gt; (а багов за 4 дня открыли 40+), оказалось, дело в DNS, лечится так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;nameserver 8.8.8.8&amp;quot; &amp;gt; /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;При этом не заработает ifconfig, ping, nslookup, но пакеты начнут ставиться.
apt-get при установке поругивается, но ставит.&lt;/p&gt;

&lt;h1 id=&#34;zsh&#34;&gt;Zsh&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install git zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ок, сработало, ставлю свой &lt;a href=&#34;https://github.com/popstas/zsh-config&#34; target=&#34;_blank&#34;&gt;zsh-config&lt;/a&gt;
Что-то пошло не так с пайпами, но в итоге он поставился. Кстати git работает как родной.&lt;/p&gt;

&lt;p&gt;Открываю новый терминал, открывается bash, смотрю /etc/passwd, там написано, что
шелл /bin/zsh. Ладно, запускаю zsh вручную, он вывалил кучу ошибок про powerline,
что-то от zsh, никакой красоты не появилось.&lt;/p&gt;

&lt;p&gt;Ок, упрощаем, удаляю свой конфиг, открываю чистый zsh - все равно облом.&lt;/p&gt;

&lt;p&gt;Ладно, не в zsh счастье (или все-таки в нем?).&lt;/p&gt;

&lt;p&gt;Открываю &lt;code&gt;mc&lt;/code&gt;, он как бы работает, но после первого нажатия Enter курсоры перестают бегать.
Выходим, идем дальше.&lt;/p&gt;

&lt;h1 id=&#34;python&#34;&gt;Python&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install python-pip python-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Все поставилось.
Смотрим pip:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;glances&lt;/code&gt; - не работает&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.popstas.ru/blog/2015/12/10/interactive-bash-history-with-search/&#34;&gt;percol&lt;/a&gt; - работает!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ansible&lt;/code&gt; - ругается при запуске про &lt;code&gt;Function not implemented&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps_mem&lt;/code&gt; - конечно нет&lt;/li&gt;
&lt;li&gt;&lt;code&gt;httpie&lt;/code&gt; - работает!&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ssh&#34;&gt;SSH&lt;/h1&gt;

&lt;p&gt;Тащим ключ с домашней машины&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rsync popstas@home:/Users/popstas/.ssh/id_dsa ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Работает!&lt;/p&gt;

&lt;p&gt;Подключаюсь к удаленному хосту - тоже работает!
Там зашел в &lt;code&gt;mc&lt;/code&gt;, стало понятно, что глючит терминал: на удаленке курсоры тоже бегают плохо.
Ок, терминал будет, потом.&lt;/p&gt;

&lt;h1 id=&#34;php&#34;&gt;PHP&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install php5-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHP работает.
Composer ставится, но при попытке установить им что-нибудь зависает.&lt;/p&gt;

&lt;h1 id=&#34;nginx&#34;&gt;Nginx&lt;/h1&gt;

&lt;p&gt;Ставится, но не стартует, в error.log пишет, что не может прибиндиться к сокету.&lt;/p&gt;

&lt;h1 id=&#34;вывод&#34;&gt;Вывод&lt;/h1&gt;

&lt;p&gt;Пользоваться этим сейчас конечно нельзя и в ближайший месяц думаю можно не надеяться.
Я рассчитывал на большее, ну ладно, будем надеяться, что у Microsoft получится сделать
полноценный линукс, хотя видно, что работы тут еще немеряно.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Windows 10 build 14316 со встроенной Ubuntu и bash через программу Microsoft Insider Preview доступна не всем</title>
      <link>http://blog.popstas.ru/blog/2016/04/07/windows-ubuntu-bash-insider-update-not-available/</link>
      <pubDate>Thu, 07 Apr 2016 00:26:00 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/04/07/windows-ubuntu-bash-insider-update-not-available/</guid>
      <description>&lt;p&gt;Все конечно слышали, что Microsoft и Canonical сговорились и встроили в винду линукс. Так вот, его пока еще нельзя потрогать.&lt;/p&gt;

&lt;p&gt;UPD 11.04.2016: сборка 14316 дошла до меня, смотрите инструкцию по настройке.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/CommandLine-Documentation/issues/5&#34; target=&#34;_blank&#34;&gt;issue про недоступность сборки 14316&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.zacorp.ru/main/kak-vklyuchit-podderzhku-ubuntu-v-windows-10/&#34; target=&#34;_blank&#34;&gt;Инструкция по обновлению на русском&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://az648995.vo.msecnd.net/win/2016/04/bash-1024x569.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Вчера утром пришло письмо от Microsoft:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Только что закончилась ежегодная конференция разработчиков Build 2016, на которой мы представили новые функции Windows 10.
Вы сможете в числе первых опробовать эти новые функции, выбрав &amp;ldquo;быстрый&amp;rdquo; или &amp;ldquo;медленный&amp;rdquo; круг обновлений. Подробную информацию о новых возможностях читайте в записи блога Гейба о последней сборке Windows 10 Insider Preview. Обратите внимание, что для участников программы предварительной оценки, которые хотят выполнить чистую установку этой сборки или запустить ее в виртуальной машине, доступны ISO-образы. (на английском языке.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Я конечно пришел домой вечером, скачал ISO, поставил на Virtualbox, сегодня на обеде думал: &amp;ldquo;Приду домой, посмотрю, что там за линукс&amp;rdquo;. Удивлялся, что до сих пор не гуглятся обзоры фичи.&lt;/p&gt;

&lt;p&gt;Включил виртуалку, x64, English, что дальше делать - не понятно. Нагуглил официальные страницы фичи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.windows.com/windowsexperience/2016/04/06/announcing-windows-10-insider-preview-build-14316/&#34; target=&#34;_blank&#34;&gt;Анонс билда&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/commandline/wsl/about&#34; target=&#34;_blank&#34;&gt;Видео с конференции BUILD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/CommandLine-Documentation&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/CommandLine-Documentation/blob/master/commandline/WSL/install_guide.md&#34; target=&#34;_blank&#34;&gt;Инструкция по включению фичи&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Уже написана &lt;a href=&#34;http://blog.zacorp.ru/main/kak-vklyuchit-podderzhku-ubuntu-v-windows-10/&#34; target=&#34;_blank&#34;&gt;инструкция по обновлению до Windows subsystem for Linux&lt;/a&gt; на русском, но до рабочей фичи ее автор тоже не дошел.&lt;/p&gt;

&lt;p&gt;Чтобы обновление пришло, нужно в настройках центра обновлений включить режим разработчика, переключиться на Insider level: fast, обновиться минимум до build 14316&lt;/p&gt;

&lt;p&gt;Все стало понятно из этого &lt;a href=&#34;https://github.com/Microsoft/CommandLine-Documentation/issues/5&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;, кто-то, включая меня, застрял на сборке 14295.&lt;/p&gt;

&lt;p&gt;Ждем.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CHANGELOG.md: ручное и автоматическое ведение истории изменений проекта в Git</title>
      <link>http://blog.popstas.ru/blog/2016/03/06/changelog-dot-md-generate-from-git-conventions/</link>
      <pubDate>Sun, 06 Mar 2016 10:09:13 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/03/06/changelog-dot-md-generate-from-git-conventions/</guid>
      <description>&lt;p&gt;С начала января я веду свой &lt;a href=&#34;http://blog.popstas.ru/blog/2016/01/17/torrent-transmission-client-for-weburg/&#34;&gt;проектик&lt;/a&gt;, на котором обкатываю новые для меня технологии:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Статический анализ кода, phpcs, phpmd, Scrutinizer&lt;/li&gt;
&lt;li&gt;Автоматическая сборка, Travis CI&lt;/li&gt;
&lt;li&gt;Unit тесты, PHPUnit&lt;/li&gt;
&lt;li&gt;Покрытие кода, Coveralls&lt;/li&gt;
&lt;li&gt;Работу через задачи для любых изменений, Github Issues, PhpStorm tasks&lt;/li&gt;
&lt;li&gt;Документирование всего: README, CHANGELOG, сайт проекта, &amp;ndash;help&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В этом посте изложена история изменений моего мнения о разных генераторах историй изменения.&lt;/p&gt;

&lt;p&gt;Tl;dr: conventional-changelog, стандартизация коммитов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-03/changelog.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;changelog-md&#34;&gt;CHANGELOG.md&lt;/h1&gt;

&lt;p&gt;Понятная для человека история изменений проекта нужна. Тут надо заметить что такими историями не являются:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Issues проекта, ветка в менеджере задач, доска проекта и т.п.&lt;/li&gt;
&lt;li&gt;git log проекта&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Файл CHANGELOG.md в корне проекта стал стандартом де-факто для проектов, в котором ведется история изменений, Gitlab даже делает для него отдельную вкладку на странице репозитория.&lt;/p&gt;

&lt;p&gt;Про это, конечно, есть &lt;a href=&#34;http://keepachangelog.com/&#34; target=&#34;_blank&#34;&gt;сайт&lt;/a&gt;, &lt;a href=&#34;https://github.com/olivierlacan/keep-a-changelog&#34; target=&#34;_blank&#34;&gt;репозиторий на Github&lt;/a&gt; с тысячей звезд, проблема явно беспокоит людей.&lt;/p&gt;

&lt;p&gt;Про ведение CHANGELOG я задумался, когда изучал проект &lt;a href=&#34;https://github.com/hashicorp/otto/&#34; target=&#34;_blank&#34;&gt;otto&lt;/a&gt;, когда писал про него &lt;a href=&#34;http://habrahabr.ru/post/273009/&#34; target=&#34;_blank&#34;&gt;статью на хабр&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;структура-у-changelog-более-менее-у-всех-одна-и-та-же&#34;&gt;Структура у CHANGELOG более-менее у всех одна и та же:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Версия и дата релиза&lt;/li&gt;
&lt;li&gt;Сломанные обратные совместимости&lt;/li&gt;
&lt;li&gt;Новые фичи&lt;/li&gt;
&lt;li&gt;Прочие изменения и улучшения&lt;/li&gt;
&lt;li&gt;Исправленные баги&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вести такой документ достаточно просто, я за 120 коммитов почти не забывал это делать. В файле нужно всегда держать вверху секцию Next Release с подготовленными заголовками, как-то так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Next Release

BREAKING CHANGES:

FEATURES:

IMPROVEMENTS:

BUG FIXES:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Перед коммитом я всегда просматриваю дифф, в это время я записываю в коммент к коммиту кратко изменение в первую строку и более подробно в третью, если изменений больше одного, делаю в виде списка. Если про это есть задача, нужно упомянуть ее в виде #123 ссылки, Github умный и такие ссылки делает активными.&lt;/p&gt;

&lt;p&gt;Так вот, нужно просто добавить в этот процесс копипасту коммента к коммиту в CHANGELOG, с раскладыванием по категориям изменений.&lt;/p&gt;

&lt;p&gt;Во время релиза называем секцию, ставим ей дату, копипастим заголовки.&lt;/p&gt;

&lt;p&gt;Процедура очень простая, настолько простая, что хочется ее поручить роботу.&lt;/p&gt;

&lt;h2 id=&#34;github-changelog-generator&#34;&gt;github_changelog_generator&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/skywinder/github-changelog-generator&#34; target=&#34;_blank&#34;&gt;github_changelog_generator&lt;/a&gt; - ruby утилита, которая умеет генерировать CHANGELOG.md из любого репозитория. На выходе получаем документ типа &lt;a href=&#34;https://github.com/skywinder/github-changelog-generator/blob/master/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;этого&lt;/a&gt;, наполненный ссылками на задачи и пулл-реквесты, разбитый по категориям, все круто, как в рекламе. У меня получилось совсем не так красиво.&lt;/p&gt;

&lt;p&gt;Что мне не понравилось в этом генераторе:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Текст коммитов никак не учитывает, как и текст задач.&lt;/li&gt;
&lt;li&gt;Чтобы она нормально работала, нужно по полной использовать Github Issues и метки для них, пулл-реквесты, в общем сильно завязано на Github (кто бы мог подумать?), иначе будут генериться просто ссылки на диффы между тегами.&lt;/li&gt;
&lt;li&gt;Нельзя указывать свои секции (например, Breaking changes встроенного нет), но есть &lt;a href=&#34;https://github.com/skywinder/github-changelog-generator/issues/316&#34; target=&#34;_blank&#34;&gt;issue #316&lt;/a&gt; про это, судя по активности проекта, они скоро появятся.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что понравилось:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Поведение из коробки что-то генерирует, даже если вы не думали про CHANGELOG.md до этого и не использовали Github фишки, это лучше, чем ничего. Но не намного.&lt;/li&gt;
&lt;li&gt;Можно привязывать свои метки к существующим секциям лога.&lt;/li&gt;
&lt;li&gt;Можно настраивать как параметрами к команде, так и конфигом. При запуске скрипт говорит: &lt;code&gt;Performing task with options&lt;/code&gt;, так вот, каждую строку из перечисленного ниже конфига можно вставить в файл &lt;code&gt;.github_changelog_generator&lt;/code&gt; и переопределить, заменив &lt;code&gt;_&lt;/code&gt; на &lt;code&gt;-&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Поддерживает сосуществование заполняемой вручную версии (которая все равно лучше автоматической) и генерируемого лога, для этого нужно переложить старый CHANGELOG.md в HISTORY.md (или другой файл, указав его в конфиге).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В общем, github_changelog_generator в моем случае подходит хорошо,
если вся работа ведется на Github, это самый простой способ получить красивый CHANGELOG.md&lt;/p&gt;

&lt;p&gt;Но на этом я не успокоился, основная причина в том, что на рабочие проекты на Github я не делаю. Хотелось более общего решения.&lt;/p&gt;

&lt;h2 id=&#34;git-extras-changelog&#34;&gt;git-extras changelog&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tj/git-extras&#34; target=&#34;_blank&#34;&gt;tj/git-extras&lt;/a&gt; - это &lt;a href=&#34;https://github.com/tj/git-extras/blob/master/Commands.md&#34; target=&#34;_blank&#34;&gt;огромный&lt;/a&gt; (около 50) пакет дополнительных команд, упрощающих работу с git. Я его раньше уже видел, но в то время подумал, что мне и встроенных в git команд слишком много. Но в поисках генератора снова набрел на него, у него есть такая команда.&lt;/p&gt;

&lt;p&gt;Вот таким нехитрым способом можно в одну команду сгенерировать и запушить лог для проекта, где его не было, но версии помечались тегами и комменты к коммитам были осмысленными:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git changelog -a -p -x &amp;gt; CHANGELOG.md &amp;amp;&amp;amp; git add CHANGELOG.md &amp;amp;&amp;amp; git commit CHANGELOG.md -m &amp;quot;add CHANGELOG.md&amp;quot; &amp;amp;&amp;amp; git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для пробы сделал лог для &lt;a href=&#34;https://github.com/popstas/site-setup/blob/5cb4f52bfc5909bac8b8bc77540cf3283b94ff2a/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;site-setup&lt;/a&gt;, &lt;a href=&#34;https://github.com/popstas/server-scripts/blob/009d82420fa4623417cf437b00df36c662c759a2/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;server-scripts&lt;/a&gt;, &lt;a href=&#34;https://github.com/popstas/drupal-scripts/blob/b0b7a5907798ebde714471fbf1611c3232df5925/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;drupal-scripts&lt;/a&gt;, на этом успокоился, больше в общем и тестить не на чем.&lt;/p&gt;

&lt;p&gt;Ниже я отказался от него в пользу &lt;code&gt;conventional changelog&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;плюсы&#34;&gt;Плюсы:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Простой как дверь, выполняешь команду, получаешь список изменений, разделенных версиями&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;минусы&#34;&gt;Минусы:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Нет почти никаких настроек&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rafinskipg-git-changelog&#34;&gt;rafinskipg/git-changelog&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rafinskipg/git-changelog&#34; target=&#34;_blank&#34;&gt;rafinskipg/git-changelog&lt;/a&gt; - node.js cкрипт, который парсит коммиты, написанные по &lt;a href=&#34;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#&#34; target=&#34;_blank&#34;&gt;стандартам Angular&lt;/a&gt;. Я их прочитал, оказалось, что стандарты годные, к angular никак не привязаны.&lt;/p&gt;

&lt;p&gt;Конфликтует с git-extras, так как оба они хотят называться git-changelog. Этот я сделал симлинком &lt;code&gt;git-changelog-angular&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Параметров у скрипта немного, я с ними поигрался, но ничего хорошего у меня с этим тулом не вышло. Идем дальше.&lt;/p&gt;

&lt;h2 id=&#34;conventional-changelog&#34;&gt;conventional-changelog&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/stevemao/conventional-changelog-cli&#34; target=&#34;_blank&#34;&gt;stevemao/conventional-changelog-cli&lt;/a&gt; - node.js скрипт, также нацелен на стандарты Angular, но, &lt;a href=&#34;https://github.com/stevemao/conventional-changelog-cli#why&#34; target=&#34;_blank&#34;&gt;по заявлениям&lt;/a&gt; авторов это как раз то, что нужно:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;поддерживает свои форматы коммитов и несколько общих: &amp;lsquo;angular&amp;rsquo;, &amp;lsquo;atom&amp;rsquo;, &amp;lsquo;codemirror&amp;rsquo;, &amp;lsquo;ember&amp;rsquo;, &amp;lsquo;eslint&amp;rsquo;, &amp;lsquo;express&amp;rsquo;, &amp;lsquo;jquery&amp;rsquo;, &amp;lsquo;jscs&amp;rsquo;, &amp;lsquo;jshint&amp;rsquo;&lt;/li&gt;
&lt;li&gt;поддерживает шаблоны&lt;/li&gt;
&lt;li&gt;протестирован, в отличие от github_changelog_generator&lt;/li&gt;
&lt;li&gt;отвязан от Github&lt;/li&gt;
&lt;li&gt;имеет модульную структуру и несколько модулей вокруг себя&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Воспользовавшись &lt;code&gt;conventional-commits-detector&lt;/code&gt;, узнал, что мои комменты к коммитам больше всего похожи на стандарт &lt;code&gt;eslint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Сгенерированный лог дал понять, что в eslint принято указывать категорию и через двоеточие суть, так коммиты в релизе разбиваются по категориям. Но в целом, конечно, коммиты были названы неправильно и хорошего лога не получилось.&lt;/p&gt;

&lt;p&gt;Зато запуск без указания пресета сообщений выдал почти то же, что и &lt;code&gt;git-extras&lt;/code&gt;, но вдобавок к этому задал мажорным и минорным версиям разный уровень и указал ссылку на коммит на Github для каждого коммита.&lt;/p&gt;

&lt;p&gt;Сгенерировать лог с нуля можно командой:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conventional-changelog -i CHANGELOG.md -s -r 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого я конечно побежал исправлять логи у проектов, которым сделал логи час назад, вот что вышло: &lt;a href=&#34;https://github.com/popstas/site-setup/blob/fd159ed7848aaf8695642bcb53c795922d307dd6/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;site-setup&lt;/a&gt;, &lt;a href=&#34;https://github.com/popstas/server-scripts/blob/ef6138faf0179f31929ff0d90d98466749d4f85b/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;server-scripts&lt;/a&gt;, &lt;a href=&#34;https://github.com/popstas/drupal-scripts/blob/3eb923c09e319a163f9fea9669dfa735b60044c1/CHANGELOG.md&#34; target=&#34;_blank&#34;&gt;drupal-scripts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Для проектов на своем Gitlab все сложнее: чтобы правильно делались ссылки на коммиты, нужно, во-первых, указать адрес проекта через файл package.json:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;myproject&amp;quot;,
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;http://my.gitlab.ru/projects/myproject.git&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А во-вторых не знаю, что надо сделать, он генерит ссылки с сокращенными хэшами, которые Github понимает, а Gitlab открывает страницу списка коммитов, т.к. ему нужен полный хэш, шаблон сходу не нашел.&lt;/p&gt;

&lt;p&gt;Дальше искать не стал, думаю это оно самое.&lt;/p&gt;

&lt;p&gt;Кроме лучшего результата из коробки и полной кастомизации мне в нем понравились модули:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ajoslin/angular-precommit&#34; target=&#34;_blank&#34;&gt;angular-precommit&lt;/a&gt; - готовый валидатор сообщений к коммитам&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marionebl/conventional-changelog-lint&#34; target=&#34;_blank&#34;&gt;conventional-changelog-lint&lt;/a&gt; - скрипт для pre-commit хука, проверяющий сообщения коммитов на соответствие стандартам, стандарты описываются в файле&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stevemao/conventional-github-releaser&#34; target=&#34;_blank&#34;&gt;conventional-github-releaser&lt;/a&gt; - автоматическое создание релизов на Github. У меня они уже создаются, но приходится вручную заходить туда и править сообщение к релизу&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;выводы&#34;&gt;Выводы&lt;/h1&gt;

&lt;p&gt;Для того, чтобы генератор создавал по-настоящему хорошие логи, важно определиться с форматом сообщений к коммитам, научиться следовать ему и научить роботов понимать наш формат, чтобы роботы &lt;del&gt;поработили людей&lt;/del&gt; помогали правильно и не напрягаясь вести историю изменеий проекта в процессе, а не после работы над проектом.&lt;/p&gt;

&lt;p&gt;Для себя я нашел инструмент, которым я теперь могу за 5 минут создавать историю изменений для проектов на основе коммитов.&lt;/p&gt;

&lt;p&gt;Генерация CHANGELOG.md - шаг в сторону хорошей и актуальной документации по проекту, которая не будет занимать часы или дни, она будет частью рабочего процесса, конечно для маленького проекта из одного программиста это избыточно, мягко говоря, но надо же с чего-то начинать.&lt;/p&gt;

&lt;h2 id=&#34;upd-08-03-2016&#34;&gt;UPD 08.03.2016&lt;/h2&gt;

&lt;p&gt;Добавил валидатор:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g conventional-changelog-lint
echo &#39;conventional-changelog-lint -e&#39; &amp;gt; .git/hooks/commit-msg
chmod +x .git/hooks/commit-msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого коммиты с неправильными сообщениями перестанут проходить.&lt;/p&gt;

&lt;p&gt;Перед релизом генерирую CHANGELOG.md:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conventional-changelog -p angular -i CHANGELOG.md -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Это допишет в лог содержимое коммитов с последнего релиза (semver тега). После этого остается поправить руками то, что не нравится, проставить версию.&lt;/p&gt;

&lt;p&gt;После этого я генерирую документацию специфичной для проекта командой, коммит, тег, пуш:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add .
git commit -m &#39;docs: v0.6.0&#39;
git push --follow-tags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого релиз. Релиз будем делать через &lt;code&gt;conventional-github-releaser&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g conventional-github-releaser
CONVENTIONAL_GITHUB_RELEASER_TOKEN=your_public_repo_token conventional-github-releaser -p angular
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Еще не разобрался с тем, как это скрестить с выкладкой PHAR архива с Travis: для &lt;code&gt;github-releaser&lt;/code&gt; нужно, чтобы релиза еще не было, но он создается автоматически при пуше тега на Github. После удаления релиза (превращения в Draft), github-releaser отработал, вставил данные CHANGELOG в релиз, все как надо.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Интеграция Git, Gitlab и Planfix почти как на Github</title>
      <link>http://blog.popstas.ru/blog/2016/03/02/git-gitlab-planfix-integration/</link>
      <pubDate>Wed, 02 Mar 2016 00:49:29 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/03/02/git-gitlab-planfix-integration/</guid>
      <description>&lt;p&gt;Распробовал тут на неделе интеграцию задач Github и самого Git issue tracker.&lt;/p&gt;

&lt;p&gt;Ниже будет написано, как настроить в &lt;a href=&#34;https://planfix.ru/&#34; target=&#34;_blank&#34;&gt;Планфиксе&lt;/a&gt; такое поведение:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;В коммите упоминаем задачу, например, &lt;code&gt;Правки футера шаблона, https://test.planfix.ru/task/123456&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;После push в удаленный репозиторий в упомянутой задаче появляется комментарий с текстом коммита и ссылкой на страницу коммита
на Gitlab, если проект подключен к репозиторию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tl;dr: настраивается post-receive hook в Git на удаленном сервере,
после каждого пуша анализируются сообщения пришедших коммитов, коммиты, содержащие ссылки на задачи отправляются в задачи по email.&lt;/p&gt;

&lt;p&gt;Вся интеграция делается в одном файле, код хука лежит здесь -
&lt;a href=&#34;https://github.com/popstas/server-scripts/blob/master/bin/git-hook-post-receive&#34; target=&#34;_blank&#34;&gt;git-hook-post-receive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-03/planfix_logo.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Здесь надо в 2 словах рассказать о нашем workflow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Компания занимается разработкой и поддержкой около 100 сайтов.&lt;/li&gt;
&lt;li&gt;Каждый сайт использует Git, репозиторий лежит прямо в корне сайта, bare репозитории отсутствуют.&lt;/li&gt;
&lt;li&gt;Часто бывают мелкие правки на разных сайтах.&lt;/li&gt;
&lt;li&gt;90% сайтов на Drupal 7, в котором половина хранится в базе данных.&lt;/li&gt;
&lt;li&gt;Во время правки контент-менеджер или клиент могут пользоваться сайтом и менять на нем данные&lt;/li&gt;
&lt;li&gt;Разработчик выкачивает проект в PhpStorm, настаивает сохранение по Ctrl+S изменений на боевом сайте,
таким образом получается, что когда приходит время пушить, на удаленном сервере фактически уже есть все изменения.&lt;/li&gt;
&lt;li&gt;Разработчик также может напрямую править код сайта на удаленном сервере по SFTP, не выкачивая проект,
после чего зайти по SSH на удаленный сервер и сделать коммит прямо оттуда.&lt;/li&gt;
&lt;li&gt;Git по сути используется не для доставки изменений на боевой сайт,
а для их доставки на компы разработчиков и ведения журнала изменений сайта.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;github-issues&#34;&gt;Github issues&lt;/h2&gt;

&lt;p&gt;Кто не знает про issues гитхаба, расскажу вкратце о его фишках:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;В задачах можно ссылаться на коммиты и другие задачи по номерам, они автоматически становятся ссылками.&lt;/li&gt;
&lt;li&gt;В коммитах можно ссылаться на задачи так же: &lt;code&gt;#123&lt;/code&gt;, такой коммит автоматом упоминается в задаче.&lt;/li&gt;
&lt;li&gt;В PhpStorm можно смотреть список открытых issues и создавать из них задачи в IDE, что позволяет автоматом создавать чейнджлист,
ветку для выполнения задачи, в коммите сразу будет ссылка на задачу (это все по желанию).&lt;/li&gt;
&lt;li&gt;Можно закрывать задачу прямо из коммита, для этого достаточно упомянуть его рядом с одним из ключевых слов,
например, &lt;code&gt;closes #123&lt;/code&gt; после пуша в гитхаб закроет указанную задачу.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;А главное, что все связано и из любого места можно перейти на связанные действия.&lt;/p&gt;

&lt;p&gt;Я уже краем уха слышал и видел обо всем этом и видел в чужих репозиториях, но вся картина нарисовалась только после использования.
Да и к тому же на гитхабе до этого сталкивался только с pull-request&amp;rsquo;ами, там немного другое поведение.&lt;/p&gt;

&lt;h2 id=&#34;phpstorm-tasks&#34;&gt;PhpStorm tasks&lt;/h2&gt;

&lt;p&gt;В PhpStorm есть интеграция с менеджерами задач, Github там конечно есть, Планфикса там конечно нет,
но зато если у менеджера задач есть API, можно интегрировать неподдерживаемый сервис.
У Планфикса API есть, но из коробки он не подойдет для этой интеграции, нужно писать свои обертки.
В общем-то это дает не много, всего лишь можно будет получать список задач по команде из шторма, и дописывать в коммит ссылку на задачу.&lt;/p&gt;

&lt;p&gt;Кстати таски в шторме помогают и без интеграции с трекером: Ctrl+Shift+A - open task, автоматом чистятся все вкладки
(создается контекст задачи), создается ветка в гите, changelist, по close task - коммит, я недавно начал пользоваться.&lt;/p&gt;

&lt;p&gt;Но гораздо интереснее интеграция в другую сторону: ссылки из задач на коммиты.&lt;/p&gt;

&lt;p&gt;Когда я разобрался с тем, как устроена интеграция задач в гитхабе, до меня быстро дошло:
просто менеджер задач должен уметь парсить текст коммита, приходящий из гита и делать на основе этого какие-то действия.
С этим тоже пока облом: в Планфиксе на данный момент нет обработки писем, прилетающих в задачи, зато
&lt;a href=&#34;https://planfix.ru/docs/%D0%9A%D0%B0%D0%BA_%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D1%83_%D0%BF%D0%BE_e-mail%3F&#34; target=&#34;_blank&#34;&gt;есть обработка писем&lt;/a&gt;,
приходящих на email юзера, что позволяет надеяться на появление обработки писем, приходящих на email задачи.&lt;/p&gt;

&lt;h2 id=&#34;gitlab&#34;&gt;Gitlab&lt;/h2&gt;

&lt;p&gt;Самые активные проекты мы дублируем на наш внутренний Gitlab. Использование довольно извращенное,
Gitlab сейчас никак не участвует в рабочем процессе, являясь просто зеркалом и веб-интерфейсом для просмотра коммитов.&lt;/p&gt;

&lt;p&gt;На машине разработчика настраивается &lt;code&gt;pre-push&lt;/code&gt; хук, который пушит также в Gitlab:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #586E75&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span style=&#34;color: #268BD2&#34;&gt;remote&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;$1&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #719e07&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #268BD2&#34;&gt;$remote&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt; !&lt;span style=&#34;color: #719e07&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;gitlab&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;$(&lt;/span&gt;git remote show &lt;span style=&#34;color: #93A1A1&#34;&gt;|&lt;/span&gt; grep -c &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;gitlab&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #719e07&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #2AA198&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color: #93A1A1&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color: #719e07&#34;&gt;then&lt;/span&gt;
        git push gitlab master
&lt;span style=&#34;color: #719e07&#34;&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;git-и-planfix&#34;&gt;Git и Planfix&lt;/h2&gt;

&lt;p&gt;Никакой готовой интеграции между Git и Планфиксом нет, зато обе системы гибкие и позволяют лепить уникальные решения без больших усилий.&lt;/p&gt;

&lt;p&gt;Git поддерживает хуки: скрипты, запускающиеся по определенным событиям.&lt;/p&gt;

&lt;p&gt;У каждой задачи в Планфиксе есть свой email адрес, если послать на него письмо, оно придет в задачу в виде комментария,
если с email отправителя связан пользователь, то письмо придет как будто от него.&lt;/p&gt;

&lt;p&gt;Значит нам нужно отправлять email из Git в Планфикс на адрес задачи.&lt;/p&gt;

&lt;h1 id=&#34;связываем-все-вместе&#34;&gt;Связываем все вместе&lt;/h1&gt;

&lt;p&gt;Вся интеграция делается в одном файле, код хука лежит здесь -
&lt;a href=&#34;https://github.com/popstas/server-scripts/blob/master/bin/git-hook-post-receive&#34; target=&#34;_blank&#34;&gt;git-hook-post-receive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Чтобы подключить хук, надо положить скрипт в папку &lt;code&gt;.git/hooks/post-receive&lt;/code&gt; и сделать его исполняемым,
для этого надо выполнить в корне проекта:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;curl -s &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;https://raw.githubusercontent.com/popstas/server-scripts/master/bin/average&amp;quot;&lt;/span&gt; &amp;gt; .git/hooks/post-receive
chmod +x .git/hooks/post-receive
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Так как у нас много проектов, я храню его в отдельной общей папке, а в каждом репозитории создаю символическую ссылку на него.&lt;/p&gt;

&lt;p&gt;Хук получает список коммитов, пришедших с последним пушем, находит первую ссылку на задачу Планфикса и отправляет туда письмо.&lt;/p&gt;

&lt;h4 id=&#34;о-письме&#34;&gt;О письме&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Отправитель&lt;/strong&gt;: email того, кто сделал коммит. По этой причине email в git config и email в профиле юзера Планфикса должны совпадать.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Получатель&lt;/strong&gt;: email задачи Планфикса&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Тема письма&lt;/strong&gt;: &lt;code&gt;@commit @nonotify&lt;/code&gt;, @nonotify для того, чтобы не уведомлять всех участников задачи о коммите,
&lt;code&gt;@commit&lt;/code&gt; ничего не значит, может быть потом пригодится для поиска таких комментов, хотя в отчетах текст комментария все равно использовать нельзя.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Текст письма&lt;/strong&gt;: текст коммита. Если репозиторий имеет зеркало на Gitlab, то в конец текста будет добавлена ссылка на коммит.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Чтобы хук добавлял ссылку на Gitlab, не придумал ничего лучше, чем добавить remote &lt;code&gt;gitlab&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add gitlab ssh://git@org.ru:10022/sites/test.ru.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого хук будет извлекать из этого адреса URL &lt;a href=&#34;http://org.ru/sites/test&#34; target=&#34;_blank&#34;&gt;http://org.ru/sites/test&lt;/a&gt;, который является главной страницей репозитория.
Сайт при всем при этом не имеет доступа к Gitlab, поэтому push и pull в этот remote работать не будут.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>average: измерение среднего времени выполнения команды в bash</title>
      <link>http://blog.popstas.ru/blog/2016/02/29/average-time-of-script-execution-in-bash/</link>
      <pubDate>Mon, 29 Feb 2016 03:46:56 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/02/29/average-time-of-script-execution-in-bash/</guid>
      <description>&lt;p&gt;Периодически хочется посчитать среднее время, у меня были такие сценарии:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;простая проверка скорости загрузки страницы&lt;/li&gt;
&lt;li&gt;подбор оптимальных параметров к команде&lt;/li&gt;
&lt;li&gt;сравнение разных команд&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Раньше я просто запускал несколько раз с &lt;code&gt;time&lt;/code&gt;, смотрел результат, у уме делил.
Но мне это надоело, поэтому написал скрипт &lt;code&gt;average&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Код лежит здесь - &lt;a href=&#34;https://github.com/popstas/server-scripts/blob/master/bin/average&#34; target=&#34;_blank&#34;&gt;https://github.com/popstas/server-scripts/blob/master/bin/average&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Поставить можно так:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #002B36&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;curl -s &lt;span style=&#34;color: #2AA198&#34;&gt;&amp;quot;https://raw.githubusercontent.com/popstas/server-scripts/master/bin/average&amp;quot;&lt;/span&gt; &amp;gt; /usr/local/bin/average
chmod +x /usr/local/bin/average
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Использовать можно так:&lt;/p&gt;

&lt;p&gt;Запуск команды по умолчанию, 5 циклов:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average &#39;command&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Запуск команды с указанным кол-вом циклов:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average 10 &#39;command&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Запуск команды с передачей кол-ва циклов через переменную окружения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export CYCLES=5
average &#39;command&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Чтобы не показывать вывод команды, можно обрезать его через tail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average &#39;command&#39; | tail -n1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;узнать-среднее-время-загрузки-страницы&#34;&gt;Узнать среднее время загрузки страницы:&lt;/h3&gt;

&lt;p&gt;С учетом кэша:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average &#39;curl -s &amp;quot;http://example.com/&amp;quot; &amp;gt; /dev/null&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В обход кэша:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average &#39;curl -s &amp;quot;http://example.com/?t=$RANDOM&amp;quot; &amp;gt; /dev/null&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;продвинутое-использование&#34;&gt;Продвинутое использование&lt;/h2&gt;

&lt;p&gt;Мне надо было узнать оптимальное количество параллельных процессов для запуска тестов,
теперь я могу узнать это запуском одной команды:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for p in {1..10}; do echo &amp;quot;$p&amp;quot; - $(average &amp;quot;vendor/bin/paratest -p $p&amp;quot; | tail -n1); done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Команда переберет кол-во процессов от 1 до 10, по каждой итерации выведет среднее время.&lt;/p&gt;

&lt;p&gt;После запуска получил такие результаты:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for p in {1..10}; do echo &amp;quot;$p&amp;quot; - $(average &amp;quot;vendor/bin/paratest -p $p&amp;quot; | tail -n1); done

1 - 1 loops, best of 5: 13.9 sec per loop
2 - 1 loops, best of 5: 7.51 sec per loop
3 - 1 loops, best of 5: 5.51 sec per loop
4 - 1 loops, best of 5: 4.51 sec per loop
5 - 1 loops, best of 5: 4.42 sec per loop
6 - 1 loops, best of 5: 4.71 sec per loop
7 - 1 loops, best of 5: 4.21 sec per loop
8 - 1 loops, best of 5: 4.23 sec per loop
9 - 1 loops, best of 5: 4.13 sec per loop
10 - 1 loops, best of 5: 4.33 sec per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Видно, что после 4 потоков разницы почти нет, а вот комп от запуска кучи параллельных процессов тормозит
очень даже заметно.&lt;/p&gt;

&lt;p&gt;Конечно, в этом случае много ума не надо, чтобы понять, что кол-во процессов должно быть по кол-ву ядер, но я что-то засомневался :)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Как я обрабатываю входящие потоки контента через RSS и Pocket или моя воронка статей</title>
      <link>http://blog.popstas.ru/blog/2016/02/27/content-consumption-pyramid-rss/</link>
      <pubDate>Sat, 27 Feb 2016 14:48:03 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/02/27/content-consumption-pyramid-rss/</guid>
      <description>&lt;p&gt;Хочу поделиться своим способом быть в курсе всего интересного в мире IT, читать много статей и знать, где быстро найти нужную статью.&lt;/p&gt;

&lt;p&gt;Tl;dr: RSS + Twitter + Email &amp;rarr; Pocket &amp;rarr; Firefox &amp;rarr; Twitter + закладки.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-02/content_pyramid.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;источники&#34;&gt;Источники&lt;/h2&gt;

&lt;h3 id=&#34;rss&#34;&gt;RSS&lt;/h3&gt;

&lt;p&gt;RSS - мой основной источник информации. Кто не пользовался RSS, не представляет, сколько всего можно получать через ленты:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;топ статей&lt;/li&gt;
&lt;li&gt;статьи по конкретным категориям/тегам&lt;/li&gt;
&lt;li&gt;комменты к редко обновляемым постам&lt;/li&gt;
&lt;li&gt;вопросы/ответы по интересующим темам&lt;/li&gt;
&lt;li&gt;личные блоги (вообще не представляю, как можно еще читать личные блоги)&lt;/li&gt;
&lt;li&gt;подкасты&lt;/li&gt;
&lt;li&gt;новые альбомы музыкальных групп&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Для сбора всех RSS в одном месте я использую Feedly, требований к нему у меня почти нет, когда умер Google Reader,
перешел по первому результату, с тех пор пользуюсь.&lt;/p&gt;

&lt;p&gt;99% RSS я читаю с телефона в дороге и на обедах.&lt;/p&gt;

&lt;p&gt;Если по анонсу понятно, что статья полезная, я сразу пересылаю ее в Pocket и разгребаю RSS дальше.&lt;/p&gt;

&lt;p&gt;На Android использую gReader, он глючный, кто знает нормальный RSS клиент - скажите.&lt;/p&gt;

&lt;h3 id=&#34;email&#34;&gt;Email&lt;/h3&gt;

&lt;p&gt;Email рассылки не умерли, как наверное многие думают. Лично я считаю, что их легко могла бы заменить RSS лента с тем же контентом,
но она почему-то есть не у всех, видимо потому, что email проще.&lt;/p&gt;

&lt;p&gt;Написав это, я подумал: &amp;ldquo;А ведь должен быть шлюз Email-RSS!&amp;rdquo; Так и оказалось, первый результат привел меня на бесплатный сервис
&lt;a href=&#34;https://emails2rss.appspot.com&#34; target=&#34;_blank&#34;&gt;emails2rss.appspot.com&lt;/a&gt;, собранный на коленке,
который по авторизации через Google дает вам виртуальный email, на который надо оформлять подписки и настоящую RSS ленту.
Так вот при написании статьи я немного изменил свои источники контента :)
Тут есть небольшой риск потерять часть своих лент из-за смерти сервиса, но рассылки еженедельные, так что думаю я это замечу.&lt;/p&gt;

&lt;p&gt;Чтобы не валить все в одну кучу, можно создать несколько виртуальных email и RSS.&lt;/p&gt;

&lt;p&gt;Шлюз это конечно хорошо, но есть также источники email рассылок, которые завернуть будет сложнее: те, где вы регаетесь под своим email.
Это тоже решаемо: создаем фильтр в почтовом клиенте, который будет пересылать письма.
Думаю, что через пару недель я перестану получать новостные рассылки в почту.&lt;/p&gt;

&lt;h3 id=&#34;подкасты&#34;&gt;Подкасты&lt;/h3&gt;

&lt;p&gt;Подкасты я открыл для себя чуть больше года назад и быстро пожалел&amp;hellip; что так долго ими не пользовался!
У подкастов своя ниша: их можно читать, когда ты занят чем-то физически, а голова свободна:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;на улице пешком, на велике или лыжах&lt;/li&gt;
&lt;li&gt;во время ремонта, копания в огороде&lt;/li&gt;
&lt;li&gt;во время уборки, мытья посуды, домашних дел&lt;/li&gt;
&lt;li&gt;во время бездумных действий за компом (тренировка слепой печати, чистка мусора на диске)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Подкасты у меня в голове делятся на 2 типа: развлекательные и полезные. Конечно, в каждом есть и то, и другое,
но в целом разграничение достаточно четкое.&lt;/p&gt;

&lt;p&gt;У любого нормального подкаста (да у всех) есть RSS. Тут есть один момент: формат RSS подкаста отличается от обычного,
там должна быть специально размеченная ссылка на mp3, я долго не придавал этому значения,
из-за чего подписывался на RSS &lt;strong&gt;сайта&lt;/strong&gt; подкаста, а не сам подкаст.
Это лишает вас возможности автоматически скачивать их (об этом ниже, в части про плеер).
Так что вам нужно искать именно ссылку на подкаст, она часто называется ссылка на iTunes,
я ее боялся и не переходил туда, оказалось, что по ссылке лежит RSS.&lt;/p&gt;

&lt;p&gt;У подкастов обычно есть &amp;ldquo;шоуноты&amp;rdquo;, текстовое краткое содержание и список ссылок, которые обсуждали,
их тоже бывает полезно смотреть, но я забываю.&lt;/p&gt;

&lt;p&gt;На подкасты я подсел через &lt;a href=&#34;https://radio-t.com/&#34; target=&#34;_blank&#34;&gt;Радио Т&lt;/a&gt;, какое-то время слушал только их, пока не переслушал все, что было интересного.
А потом как началось&amp;hellip; Я примерно 2 месяца тренировал слепую печать по часу в день, и чтобы совместить полезное с полезным,
параллельно слушал подкасты. В таком темпе они очень быстро кончились и пришлось искать новые.&lt;/p&gt;

&lt;p&gt;Подкастов, в отличие от RSS, сравнительно немного и выбор небольшой, поэтому их еще надо найти.
&lt;a href=&#34;https://gpodder.net/user/popstas/subscriptions&#34; target=&#34;_blank&#34;&gt;Здесь&lt;/a&gt; лежит мой список, а на
&lt;a href=&#34;https://github.com/AveVlad/russia-it-podcast&#34; target=&#34;_blank&#34;&gt;AveVlad/russia-it-podcast&lt;/a&gt; самый большой список русских подкастов,
его можно дополнять, я туда заношу новое, что нахожу.&lt;/p&gt;

&lt;h3 id=&#34;видеоматериалы&#34;&gt;Видеоматериалы&lt;/h3&gt;

&lt;p&gt;Видеоматериалы попадаются единичные и в виде курсов. Разницы в общем нет, а рассказать надо о том, что сразу не приходит в голову:
большую часть выступлений можно не смотреть, а только слушать! И да, для этого есть
&lt;a href=&#34;http://www.onlinevideoconverter.com/video-converter&#34; target=&#34;_blank&#34;&gt;сервис&lt;/a&gt;, за полминуты получаем mp3 с видео, дальше все как с подкастами.&lt;/p&gt;

&lt;p&gt;Просто так втыкать в видео мне редко хочется, у таких видяшек два сценария:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;во время бездумных действий за компом&lt;/li&gt;
&lt;li&gt;во время ужина, вместо сериалов&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;twitter&#34;&gt;Twitter&lt;/h3&gt;

&lt;p&gt;Чтобы нормально использовать твиттер в режиме чтения, вам нужно отписаться ото всех, кто генерирует спам
и оставить только тех, кто твиттит интересное вам. Казалось бы, очевидная вещь, но я это сразу не понял,
начал подписываться на все подряд, дублируя функционал RSS, быстро засорил ленту и на несколько лет забыл о твиттере.&lt;/p&gt;

&lt;p&gt;Сейчас я тоже не скажу, чтобы я много инфы оттуда доставал, но случается.
Проблема в том, что найти интересных вам генераторов сложно, я этим специально не занимался,
поэтому у меня интересный генератор один, и я и так подписан на его блог.&lt;/p&gt;

&lt;h2 id=&#34;посредники&#34;&gt;Посредники&lt;/h2&gt;

&lt;h3 id=&#34;pocket&#34;&gt;Pocket&lt;/h3&gt;

&lt;p&gt;Главный агрегатор нефильтрованного контента, ставится на телефон и в браузеры, позволяет в один клик добавить статью в список на прочтение.
На телефоне статьи доступны оффлайн.&lt;/p&gt;

&lt;p&gt;Сюда попадает все:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RSS&lt;/li&gt;
&lt;li&gt;любые интересные найденные материалы&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это помогает найти статью, даже если она не пойдет дальше, а также точнее следить за количиеством прочитанных статей
(люблю я все считать, да :)&lt;/p&gt;

&lt;p&gt;В Pocket прочитывается большинство статей, но некоторые уходят на прочтение в мобильный браузер
(Pocket иногда портит оформление статьи), в Reedy или на домашний комп.&lt;/p&gt;

&lt;h3 id=&#34;браузер&#34;&gt;Браузер&lt;/h3&gt;

&lt;p&gt;В Firefox есть удобная штука: пересылка вкладки с одного устройства на другое, объединенных одним аккаунтом синхронизации.
Поэтому все, что на телефоне читать неудобно, сразу улетает на домашний комп. Для хрома тоже вроде есть что-то подобное.&lt;/p&gt;

&lt;h3 id=&#34;плеер&#34;&gt;Плеер&lt;/h3&gt;

&lt;p&gt;В плеере лежат подкасты и записи с конференций. Под плеером я имею в виду телефон, и тут надо рассказать о том,
как подкасты попадают туда. В двух словах: качалка подкастов + синхронизация файлов.&lt;/p&gt;

&lt;p&gt;Я использую gPodder для скачивания подкастов. Раньше, когда сидел на Ubuntu, пользовался местным плеером Rhytmbox для этого,
у gPodder плюсы в том, что он есть под все операционки и он дает аккаунт, где собраны все ваши подкасты.&lt;/p&gt;

&lt;p&gt;Пользоваться так: создаем аккаунт (не обязательно), задаем папку для сохранения или iPod, добавляем RSS подкастов
(в части про подкасты написано, чем они отличаются от обычных RSS) после этого подкасты будут прилетать сами,
вам остается по Ctrl+S переслать их в плеер.&lt;/p&gt;

&lt;p&gt;Если у вас не iPod, то тут есть 2 варианта: использовать синхронизацию файлов (я раньше использовал BTSync, потом перешел на Syncthing)
или, если у вас Android, поставить gPodder прямо на него. Мне больше нравится синхронизация через комп,
так как я бывает не успеваю слушать все подкасты, а они все прибывают, в итоге место на телефоне кончается.&lt;/p&gt;

&lt;p&gt;Для прослушивания использую
&lt;a href=&#34;https://play.google.com/store/apps/details?id=ak.alizandro.smartaudiobookplayer&amp;amp;hl=ru&#34; target=&#34;_blank&#34;&gt;Smart AudioBook Player&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;reedy&#34;&gt;Reedy&lt;/h3&gt;

&lt;p&gt;Из Pocket некоторые статьи читаются через &lt;a href=&#34;https://habrahabr.ru/post/220775/&#34; target=&#34;_blank&#34;&gt;Reedy&lt;/a&gt;, использую редко, но он мне нравится,
это такая программа для скорочтения: слова бегут по экрану, наподобие бегущей строки, так и читаете.
Звучит неубедительно, это надо попробовать, у меня таким способам статьи читаются в 1.5-2 раза быстрее.&lt;/p&gt;

&lt;p&gt;Минус в том, что мало что можно так прочитать:
статья должна быть без картинок, кода, формул, таблиц - только текст, иначе ничего не понятно будет.&lt;/p&gt;

&lt;h2 id=&#34;хранители&#34;&gt;Хранители&lt;/h2&gt;

&lt;p&gt;Судьба лучших материалов - попасть на долгое хранение.&lt;/p&gt;

&lt;h3 id=&#34;twitter-1&#34;&gt;Twitter&lt;/h3&gt;

&lt;p&gt;Каждую прочитанную статью, которая понравилась, я в последнее время отправляю в твиттер,
таким образом я создал для себя самую узкую часть моей воронки контентопотребления.
Не знаю зачем, но думаю, пригодится может кто-то будет меня читать, а если нет, может мне понадобятся все эти статьи,
тогда я смогу их оттуда достать.&lt;/p&gt;

&lt;h3 id=&#34;закладки&#34;&gt;Закладки&lt;/h3&gt;

&lt;p&gt;Статьи, которые пригодятся потом, я отправляю в браузер, а приходя домой, добавляю их в закладки, проставляю теги.
Это очень помогает находить контент, который уже прочитал, но был еще не в теме.
Например, вникаю в тестирование и все, что может быть полезным, скидываю в закладки, потом проще искать, когда понадобится.&lt;/p&gt;

&lt;p&gt;Самое главное не забыть сначала поискать в закладках нужную тему перед тем как гуглить.&lt;/p&gt;

&lt;h2 id=&#34;источники-для-отдыха&#34;&gt;Источники для отдыха&lt;/h2&gt;

&lt;h3 id=&#34;вконтакте&#34;&gt;Вконтакте&lt;/h3&gt;

&lt;p&gt;Ленту вконтакте за день можно читать за 1-2 минуты, рецепт тот же, что и для твиттера:
отпишитесь от спамогенераторов и от пабликов (1-2 пишущих по 3 раза в день можно и оставить).
Удалять из друзей не обязательно, можно просто не показывать записи в ленте. Тут вроде работает правило 20/80,
так что много отписывать не надо будет.&lt;/p&gt;

&lt;h3 id=&#34;музыка&#34;&gt;Музыка&lt;/h3&gt;

&lt;p&gt;Давно хотел сразу узнавать, если у групп, которые я слушаю, появляются новые альбомы. Так вот, теперь это возможно!
Я использую комбинацию RSS для групп, которые не спамят + подписка на исполнителя в яндекс музыке для всех групп.
Это работает уже пару лет, стоит один раз потратить вечер на добавление исполнителей из вашего плейлиста в подписки
и вы будете получать обновления по ним.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker в картинках</title>
      <link>http://blog.popstas.ru/blog/2016/02/26/docker-in-images/</link>
      <pubDate>Fri, 26 Feb 2016 21:29:45 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/02/26/docker-in-images/</guid>
      <description>&lt;p&gt;Оставлю здесь &lt;a href=&#34;http://habrahabr.ru/post/272145/&#34; target=&#34;_blank&#34;&gt;свой пост&lt;/a&gt; с хабра.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Перевод поста &lt;a href=&#34;http://merrigrove.blogspot.co.uk/2015/10/visualizing-docker-containers-and-images.html&#34; target=&#34;_blank&#34;&gt;Visualizing Docker Containers and Images&lt;/a&gt;, от новичка к новичкам, автор на простых примерах объясняет базовые сущности и процессы в использовании docker.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Если вы не знаете, что такое Docker или не понимаете, как он соотносится с виртуальными машинами или с инструментами configuration management, то этот пост может показаться немного сложным.&lt;/p&gt;

&lt;p&gt;Пост предназначен для тех, кто пытается освоить docker cli, понять, чем отличается контейнер и образ. В частности, будет объяснена разница между просто контейнером и запущенным контейнером.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/8ff/349/fb2/8ff349fb23f840589c479d029964b8dc.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;В процессе освоения нужно представить себе некоторые лежащие в основе детали, например, слои файловой системы UnionFS. В течение последней пары недель я изучал технологию, я новичок в мире docker, и командная строка docker показалась мне довольно сложной для освоения.&lt;/p&gt;

&lt;p&gt;По-моему, понимание того, как технология работает изнутри - лучший способ быстро освоить новый инструмент и правильно его использовать. Часто новая технология разрабатывает новые модели абстракций и привносит новые термины и метафоры, которые могут быть как будто бы понятны в начале, но без четкого понимания затрудняют последующее использование инструмента.&lt;/p&gt;

&lt;p&gt;Хорошим примером является Git. Я не мог понять Git, пока не понял его базовую модель, включая trees, blobs, commits, tags, tree-ish и прочее. Я думаю, что люди, не понимающие внутренности Git, не могут мастерски использовать этот инструмент.&lt;/p&gt;

&lt;h2 id=&#34;определение-образа-image&#34;&gt;Определение образа (Image)&lt;/h2&gt;

&lt;p&gt;Визуализация образа представлена ниже в двух видах. Образ можно определить как &amp;ldquo;сущность&amp;rdquo; или &amp;ldquo;общий вид&amp;rdquo; (union view) стека слоев только для чтения.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/243/a01/1ed/243a011ed04f455099a4ba64a87736f6.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Слева мы видим стек слоев для чтения. Они показаны только для понимания внутреннего устройства, они доступны вне запущенного контейнера на хост-системе. Важно то, что они доступны только для чтения (иммутабельны), а все изменения происходят в верхнем слое стека. Каждый слой может иметь одного родителя, родитель тоже имеет родителя и т.д. Слой верхнего уровня может быть использован как UnionFS (AUFS в моем случае с docker) и представлен в виде единой read-only файловой системы, в которой отражены все слои. Мы видим эту &amp;ldquo;сущность&amp;rdquo; образа на рисунке справа.&lt;/p&gt;

&lt;p&gt;Если вы захотите посмотреть на эти слои в первозданном виде, вы можете найти их в файловой системе на хост-машине. Они не видны напрямую из запущенного контейнера. На моей хост-машине я могу найти образы в /var/lib/docker/aufs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sudo tree -L 1 /var/lib/docker/
/var/lib/docker/
├── aufs
├── containers
├── graph
├── init
├── linkgraph.db
├── repositories-aufs
├── tmp
├── trust
└── volumes

7 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;определение-контейнера-container&#34;&gt;Определение контейнера (Container)&lt;/h2&gt;

&lt;p&gt;Контейнер можно назвать &amp;ldquo;сущностью&amp;rdquo; стека слоев с верхним слоем для записи.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/8d3/d29/494/8d3d29494dbf46f79b1be15cea7516c4.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;На изображении выше показано примерно то же самое, что на изображении про образ, кроме того, что верхний слой доступен для записи. Вы могли заметить, что это определение ничего не говорит о том, запущен контейнер или нет и это неспроста. Разделение контейнеров на запущенные и не запущенные устранило путаницу в моем понимании.&lt;/p&gt;

&lt;p&gt;Контейнер определяет лишь слой для записи наверху образа (стека слоев для чтения). Он не запущен.&lt;/p&gt;

&lt;h2 id=&#34;определение-запущенного-контейнера&#34;&gt;Определение запущенного контейнера&lt;/h2&gt;

&lt;p&gt;Запущенный контейнер - это &amp;ldquo;общий вид&amp;rdquo; контейнера для чтения-записи и его изолированного пространства процессов. Ниже изображен контейнер в своем пространстве процессов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/c72/5d3/b0b/c725d3b0be5742aca5f50310d640d0b1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Изоляция файловой системы обеспечивается технологиями уровня ядра, cgroups, namespaces и другие, позволяют докеру быть такой перспективной технологией. Процессы в пространстве контейнера могут изменять, удалять или создавать файлы, которые сохраняются в верхнем слое для записи. Смотрите изображение:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/f8e/bbf/e3b/f8ebbfe3b59346ee9cdb017b89fcb169.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Чтобы проверить это, выполните команду на хост-машине:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run ubuntu touch happiness.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вы можете найти новый файл в слое для записи на хост-машине, даже если контейнер не запущен.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# find / -name happiness.txt
/var/lib/docker/aufs/diff/860a7b...889/happiness.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;определение-слоя-образа-image-layer&#34;&gt;Определение слоя образа (Image layer)&lt;/h2&gt;

&lt;p&gt;Наконец, мы определим слой образа. Изображение ниже представляет слой образа и дает нам понять, что слой - это не просто изменения в файловой системе.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/928/23a/1a0/92823a1a03ad487586293f37e78cf74f.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Метаданные - дополнительная информация о слое, которая позволяет докеру сохранять информацию во время выполнения и во время сборки. Оба вида слоев (для чтения и для записи) содержат метаданные.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/b7e/d04/252/b7ed042525f647b986009b82d18b3fee.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Кроме того, как мы уже упоминали раньше, каждый слой содержит указатель на родителя, используя id (на изображении родительские слои внизу). Если слой не указывает на родительский слой, значит он наверху стека.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/7e9/de2/c4f/7e9de2c4f537438c8f5357d09c398289.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;расположение-метаданных&#34;&gt;Расположение метаданных&lt;/h3&gt;

&lt;p&gt;На данный момент (я понимаю, что разработчики docker могут позже сменить реализацию), метаданные слоев образов (для чтения) находятся в файле с именем &amp;ldquo;json&amp;rdquo; в папке /var/lib/docker/graph/id_слоя:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/lib/docker/graph/e809f156dc985.../json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;где &amp;ldquo;e809f156dc985&amp;hellip;&amp;rdquo; - урезанный id слоя.&lt;/p&gt;

&lt;h2 id=&#34;свяжем-все-вместе&#34;&gt;Свяжем все вместе&lt;/h2&gt;

&lt;p&gt;Теперь, давайте посмотрим на команды, иллюстрированные понятными картинками.&lt;/p&gt;

&lt;h3 id=&#34;docker-create-image-id&#34;&gt;docker create &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker create&lt;/code&gt; добавляет слой для записи наверх стека слоев, найденного по &lt;image-id&gt;. Команда не запускает контейнер.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/12c/8d5/606/12c8d56068c5416e8ca003b532ef3cdb.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;docker-start-container-id&#34;&gt;docker start &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/730/6c4/4cd/7306c44cdfdd4ead9f1f073d91dd312c.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker start&lt;/code&gt; создает пространство процессов вокруг слоев контейнера. Может быть только одно пространство процессов на один контейнер.&lt;/p&gt;

&lt;h3 id=&#34;docker-run-image-id&#34;&gt;docker run &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/730/6c4/4cd/7306c44cdfdd4ead9f1f073d91dd312c.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Один из первых вопросов, который задают люди (я тоже задавал): &amp;ldquo;В чем разница между &lt;code&gt;docker start&lt;/code&gt; и &lt;code&gt;docker run&lt;/code&gt;?&amp;rdquo; Одна из первоначальных целей этого поста - объяснить эту тонкость.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/429/f39/fc6/429f39fc67d44579a40365018dc6839e.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как мы видим, команда &lt;code&gt;docker run&lt;/code&gt; находит образ, создает контейнер поверх него и запускает контейнер. Это сделано для удобства и скрывает детали двух команд.&lt;/p&gt;

&lt;p&gt;Продолжая сравнение с освоением Git, я скажу, что &lt;code&gt;docker run&lt;/code&gt; очень похожа на &lt;code&gt;git pull&lt;/code&gt;. Так же, как и &lt;code&gt;git pull&lt;/code&gt; (который объединяет &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git merge&lt;/code&gt;), команда &lt;code&gt;docker run&lt;/code&gt; объединяет две команды, которые могут использоваться и независимо. Это удобно, но поначалу может ввести в заблуждение.&lt;/p&gt;

&lt;h3 id=&#34;docker-ps&#34;&gt;docker ps&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/441/0ed/8b7/4410ed8b7bb94de68dfae60a79a08aca.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker ps&lt;/code&gt; выводит список запущенных контейнеров на вашей хост-машине. Важно понимать, что в этот список входят только запущенные контейнеры, не запущенные контейнеры скрыты. Чтобы посмотреть список всех контейнеров, нужно использовать следующую команду.&lt;/p&gt;

&lt;h3 id=&#34;docker-ps-a&#34;&gt;docker ps -a&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/633/55a/c1a/63355ac1a27d4cf6a1f10142cc89d7b0.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker ps -a&lt;/code&gt;, где &lt;code&gt;a&lt;/code&gt; - сокращение от &lt;code&gt;all&lt;/code&gt; выводит список всех контейнеров, независимо от их состояния.&lt;/p&gt;

&lt;h3 id=&#34;docker-images&#34;&gt;docker images&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/2d2/29e/bc6/2d229ebc667244b3b478298aa3162c7e.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker images&lt;/code&gt; выводит список образов верхнего уровня (top-level images). Фактически, ничего особенного не отличает образ от слоя для чтения. Только те образы, которые имеют присоединенные контейнеры или те, что были получены с помощью pull, считаются образами верхнего уровня. Это различие нужно для удобства, так как за каждым образом верхнего уровня может быть множество слоев.&lt;/p&gt;

&lt;h3 id=&#34;docker-images-a&#34;&gt;docker images -a&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/5b6/6a9/fd9/5b66a9fd93ce4157b3cfa48984a5ca0d.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker images -a&lt;/code&gt; выводит все образы на хост-машине. Это фактически список всех слоев для чтения в системе. Если вы хотите увидеть все слои одного образа, воспользуйтесь командой &lt;code&gt;docker history&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;docker-stop-container-id&#34;&gt;docker stop &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/f34/430/e32/f34430e3231842e3b748d337993e9338.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker stop&lt;/code&gt; посылает сигнал SIGTERM запущенному контейнеру, что мягко останавливает все процессы в пространстве процессов контейнера. В результате мы получаем не запущенный контейнер.&lt;/p&gt;

&lt;h3 id=&#34;docker-kill-container-id&#34;&gt;docker kill &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/ef8/c77/3c3/ef8c773c34454292b76f798482e15463.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker kill&lt;/code&gt; посылает сигнал SIGKILL, что немедленно завершает все процессы в текущем контейнере. Это почти то же самое, что нажать Ctrl+\ в терминале.&lt;/p&gt;

&lt;h3 id=&#34;docker-pause-container-id&#34;&gt;docker pause &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/63d/de7/ed4/63dde7ed482544e0afcc2925eabc1e3d.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/70d/208/439/70d208439a1944739c5e06e716ab1975.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;В отличие от &lt;code&gt;docker stop&lt;/code&gt; и &lt;code&gt;docker kill&lt;/code&gt;, которые посылают настоящие UNIX сигналы процессам контейнера, команда &lt;code&gt;docker pause&lt;/code&gt; используют специальную возможность cgroups для заморозки запущенного пространства процессов. Подробности можно прочитать &lt;a href=&#34;https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;, если вкратце, отправки сигнала Ctrl+Z (SIGTSTP) не достаточно, чтобы заморозить все процессы в пространстве контейнера.&lt;/p&gt;

&lt;h3 id=&#34;docker-rm-container-id&#34;&gt;docker rm &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/92d/14d/d92/92d14dd9224043079a90ab80c4dbc6a6.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/a36/292/8c4/a362928c4661422797d267560ff38182.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker rm&lt;/code&gt; удаляет слой для записи, который определяет контейнер на хост-системе. Должна быть запущена на остановленном контейнерах. Удаляет файлы.&lt;/p&gt;

&lt;h3 id=&#34;docker-rmi-image-id&#34;&gt;docker rmi &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/4c2/eb5/26a/4c2eb526a35e4751a5302c954370a0fa.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/3a2/145/38a/3a214538a6e54e009f704825109393a1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker rmi&lt;/code&gt; удаляет слой для чтения, который определяет &amp;ldquo;сущность&amp;rdquo; образа. Она удаляет образ с хост-системы, но образ все еще может быть получен из репозитория через &lt;code&gt;docker pull&lt;/code&gt;. Вы можете использовать &lt;code&gt;docker rmi&lt;/code&gt; только для слоев верхнего уровня (или образов), для удаления промежуточных слоев нужно использовать &lt;code&gt;docker rmi -f&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;docker-commit-container-id&#34;&gt;docker commit &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/7d0/ec4/104/7d0ec41049b34238bb785e28897e28f0.png&#34; /&gt; или &lt;img src=&#34;https://habrastorage.org/files/325/e8e/270/325e8e27098e4cdeb956634361879388.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/daa/69c/50f/daa69c50fbc3479ba9d6497983b73a02.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker commit&lt;/code&gt; берет верхний уровень контейнера, тот, что для записи и превращает его в слой для чтения. Это фактически превращает контейнер (вне зависимости от того, запущен ли он) в неизменяемый образ.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/e3d/7d7/766/e3d7d7766165425a9148ac61369ffe9c.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;docker-build&#34;&gt;docker build&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;Dockerfile &lt;img src=&#34;https://habrastorage.org/files/847/71b/87a/84771b87a8cd4d77b63d39a3ae9dae13.png&#34; /&gt; и &lt;img src=&#34;https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png&#34; /&gt;
Со многими другими слоями.&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker build&lt;/code&gt; интересна тем, что запускает целый ряд команд:
&lt;img src=&#34;https://habrastorage.org/files/b25/36e/cac/b2536ecac84148ba9a043bb00fe3ce5a.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;На изображении выше мы видим, как команда build использует значение инструкции FROM из файла Dockerfile как базовый образ после чего:&lt;/p&gt;

&lt;p&gt;1) запускает контейнер (create и start)
2) изменяет слой для записи
3) делает commit
На каждой итерации создается новый слой. При исполнении &lt;code&gt;docker build&lt;/code&gt; может создаваться множество слоев.&lt;/p&gt;

&lt;h3 id=&#34;docker-exec-running-container-id&#34;&gt;docker exec &lt;running-container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/7d0/ec4/104/7d0ec41049b34238bb785e28897e28f0.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/4d6/cd5/21e/4d6cd521ee4d47e68d89e9ce77c8a6ca.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker exec&lt;/code&gt; применяется к запущенному контейнеру, запускает новый процесс внутри пространства процессов контейнера.&lt;/p&gt;

&lt;h3 id=&#34;docker-inspect-container-id-image-id&#34;&gt;docker inspect &lt;container-id&gt; | &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/74c/7ee/e53/74c7eee53b8f4ed8a2a606e87571fe3a.png&#34; /&gt; или &lt;img src=&#34;https://habrastorage.org/files/242/b58/b68/242b58b68acd4580b226569d81d613e5.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/898/5e8/e54/8985e8e5467a42769988a4351d0c0828.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker inspect&lt;/code&gt; получает метаданные верхнего слоя контейнера или образа.&lt;/p&gt;

&lt;h3 id=&#34;docker-save-image-id&#34;&gt;docker save &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/f2a/b8d/70d/f2ab8d70de7a4ca4959f6a7bf1fb11e3.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/d5d/bf7/3f0/d5dbf73f0f2d4d72b0ed38309e2c6a6b.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker save&lt;/code&gt; создает один файл, который может быть использован для импорта образа на другую хост-систему. В отличие от команды &lt;code&gt;export&lt;/code&gt;, она сохраняет все слои и их метаданные. Может быть применена только к образам.&lt;/p&gt;

&lt;h3 id=&#34;docker-export-container-id&#34;&gt;docker export &lt;container-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/a7f/3f4/717/a7f3f47170084dc2b75dd73e8d6a5cbb.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/36d/807/ed6/36d807ed6b304333b31f658dfb5c4326.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker export&lt;/code&gt; создает tar архив с содержимым файлов контейнера, в результате получается папка, пригодная для использования вне docker. Команда убирает слои и их метаданные. Может быть применена только для контейнеров.&lt;/p&gt;

&lt;h3 id=&#34;docker-history-image-id&#34;&gt;docker history &lt;image-id&gt;&lt;/h3&gt;

&lt;p&gt;До:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/428/150/afc/428150afc2574fd2bf32f1202c908f77.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;После:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://habrastorage.org/files/e82/45f/511/e8245f51120340b19e07c6009f2d4ce8.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Команда &lt;code&gt;docker history&lt;/code&gt; принимает &lt;image-id&gt; и рекурсивно выводит список всех слоев-родителей образа (которые тоже могут быть образами)&lt;/p&gt;

&lt;h2 id=&#34;итог&#34;&gt;Итог&lt;/h2&gt;

&lt;p&gt;Я надеюсь, вам понравилась эта визуализация контейнеров и образов. Есть много других команд (pull, search, restart, attach и другие), которые могут или не могут быть объяснены моими сравнениями.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Большой тачпад как замена мышки</title>
      <link>http://blog.popstas.ru/blog/2016/02/25/big-touchpad-as-mouse-replacement/</link>
      <pubDate>Thu, 25 Feb 2016 23:31:57 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/02/25/big-touchpad-as-mouse-replacement/</guid>
      <description>&lt;p&gt;Наслушавшись рассказов про то, какой на макбуке офигенный большой тачпад и как он легко заменяет мышку,
нашел способ испытать это на себе бесплатно. Описываю свои впечатления как обычно: плюсы, минусы, грабли, способы обхода.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-02/touchpad_wacom.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Мне повезло: у нас в офисе лежал без дела графический планшет Wacom Intuos Pen &amp;amp; Touch Medium.
Выглядит как огромный (почти А4 формата) тачпад, экрана нет, зато есть поддержка всех операционок и мультитач.&lt;/p&gt;

&lt;p&gt;Не скажу насчет винды и линукса, расскажу про мак, но уверен, что по поддержке жестов в Windows не отстает, по крайней мере у Wacom драйвера примерно одинаковые везде.&lt;/p&gt;

&lt;h1 id=&#34;плюсы&#34;&gt;Плюсы:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Скролл как на мобиле! Можно прокрутить 1000 строк и страницу любой длины за секунду, с таким же кинетическим эффектом, как на мобильном. То есть можно махнуть плавно и прокрутить чуть-чуть, а можно резко. У меня на работе мышка Logitech M705, у нее колесико не зафиксировано, ей можно делать то же самое, а вот дома такого не хватало.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Больше действий, чем на мышке. Мышки у меня были разные, бывало от 2 до 8 кнопок, последние лет 8 использую мышки с кнопками вперед-назад. У тачпада возможности намного больше.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Жесты. Если кто-то пробовал использовать жесты мышью в опере или с помощью утилит, то на тачпаде то же самое, но лучше. У меня на wacom доступны простые жесты, я не нашел софт под него, чтобы настроить свои, но даже при этом мне нравится: можно использовать от 1 до 4 пальцев, у каждого сочетания своя функция, в итоге передвигая пальцы вправо, можно вести курсор, выделять текст, переходить вперед в браузере, перетаскивать что-то или переключать текущее окно, в зависимости от сочетания. Ну и местами зум, поворот (ни разу не использовал).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Горизонтальный скролл теперь так же прост, как вертикальный. Это я не сразу понял, а когда открыл браузер на треть экрана и понял, что дотянуться до кнопки в правой части экрана за пределами видимости очень просто. По сути это для меня в некоторых случаях расширяет рабочую область экрана, которой много не бывает.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Плюс, растущий из минуса: в ситуациях, где мышкой было бы удобнее, руки тянутся к клавиатуре, надеюсь, они там найдут способы делать что надо быстрее, чем мышкой. Этого можно достичь и менее радикальными способами, но &lt;a href=&#34;https://www.youtube.com/watch?v=NnTi9B-D6LA&#34; target=&#34;_blank&#34;&gt;по бразильской системе&lt;/a&gt; все быстрее осваивается :) В PhpStorm уже почувствовал прогресс в клавиатурном управлении, хотя к этому причастен еще и &lt;a href=&#34;https://www.youtube.com/watch?v=eq3KiAH4IBI&#34; target=&#34;_blank&#34;&gt;мастер-класс по Idea&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Рука меньше устает. Запястье не упирается в стол на изгибе, а лежит на нем. Тачпадом, в отличие от мышки, можно точно управлять одними пальцами, поэтому запястье либо не касается стола, либо касается, но не играет роли опорной точки.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Можно тестить поведение сайтов на телефоне. Надуманный плюс, я это не использовал и может никогда не использую.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;минусы&#34;&gt;Минусы:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Неудобно перетаскивать. Выделение области скриншота, перетаскивание файлов - совершая подобные действия, вы рискуете не дотянуть докуда надо, так как нельзя в отличие от мышки, удерживая кнопку, передвинуть мышку и дотащить элемент.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Неудобно выделять. Все-таки точность у мыши намного выше, я за 2 дня научился точно попадать тачпадом между букв, куда мне надо, но чувствуется, что мышкой быстрее.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Мало жестов. Стандартный драйвер поддерживает 95% жестов из справки к системе и больше ничего. Нестандартного я не нашел.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Не хватает колесика от мышки. Постоянно его использую и без него обламываюсь. Открываю ссылки в новой вкладке через контекстное меню, закрываю вкладки крестиком&amp;hellip; это конечно шаг назад.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Пальцы иногда срываются. Случайно нажать или отпустить палец в неподходящий момент намного проще, чем мышкой, из-за этого бывают случайные срабатывания всякой фигни.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Чувствительность может потеряться из-за состояния ваших пальцев. Не знаю, как эппловский тачпад, а вакомовский плохо понимает слишком потные, слишком сухие, слишком пыльные пальцы. А если один палец более скользкий, чем другой (такое случается), скроллить страницу двумя пальцами становится не так удобно. С мышкой таких проблем нет.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Большой. Мышь занимает меньше места даже с учетом ее рабочей площади. По ощущениям могу сказать, что толку от такого огромного тачпада немного, проявляется только когда нужно что-то перетащить на большое расстояние.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;решение-проблем&#34;&gt;Решение проблем&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Кастомные жесты. На маке похоже решаются только покупкой эппловского тачпада, на который есть миллион программ для расширения функциональности.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Перетаскивание. Решается эппловским тачпадом.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Колесико тоже надеюсь заменить кастомным жестом.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;С пальцами ничего не сделаешь, уж какие есть, нерешаемая проблема.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;upd-15-06-2016&#34;&gt;UPD 15.06.2016&lt;/h1&gt;

&lt;p&gt;В конце мая получил свой эппловский тачпад, первую модель. Делюсь впечатлениями:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Какие проблемы решились&lt;/li&gt;
&lt;li&gt;Какие проблемы остались&lt;/li&gt;
&lt;li&gt;Какие проблемы появились&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Пойду по порядку, по минусам из обзора Wacom.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Неудобно перетаскивать. Эта проблема решена просто: добавлена задержка на отпускание. То есть при перетаскивании можно поднимать пальцы на полсекунды, элемент при этом остается захваченным. При этом, задержку можно прервать одиночным тапом.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Неудобно выделять. Тут ничего нового, выделять неудобно.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Мало жестов. Это решено. Я пока даже не искал ничего, открыл настройки универсального BetterTouchTool, там все есть.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;выводы&#34;&gt;Выводы&lt;/h1&gt;

&lt;p&gt;Тачпадом вместо мышки я пользуюсь около месяца, руки к мышке уже не тянутся, но она лежит рядом, на всякие случаи, которые бывали раза два за месяц.&lt;/p&gt;

&lt;p&gt;Как это ни странно (мне странно), думаю, что тачпад может быть удобнее мышки. Когда куплю нормальный тачпад, узнаю, так ли это.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Проверяем изменения на странице через cron</title>
      <link>http://blog.popstas.ru/blog/2016/01/31/check-webpage-changes-with-cron/</link>
      <pubDate>Sun, 31 Jan 2016 02:00:13 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/01/31/check-webpage-changes-with-cron/</guid>
      <description>&lt;p&gt;Сегодня хотел заказать ароматизаторов на &lt;a href=&#34;http://baker-flavors.blogspot.ru/&#34; target=&#34;_blank&#34;&gt;Baker Flavours&lt;/a&gt;, дошел до страницы заказа,
и увидел &amp;ldquo;Уважаемые заказчики! В связи с чрезвычайно большим количеством заказов, прием заказов временно прекращен.&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ок, будем ждать, пока эта надпись не пропадет, а чтобы не проверять руками, будем делать это на автомате и ждать уведомления.&lt;/p&gt;

&lt;p&gt;Строчка для crontab:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 20 * * * curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep &amp;quot;временно прекращен&amp;quot; &amp;gt; /dev/null || { echo &amp;quot;BF order started&amp;quot; | terminal-notifier &amp;amp;&amp;amp; open http://bakerflavors.ru/formbf.htm }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Подробности под катом.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Нужно сделать так, чтобы я узнал о том, что этот текст со страницы пропадет.&lt;/p&gt;

&lt;p&gt;Получаем содержимое страницы:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s http://bakerflavors.ru/formbf.htm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Оказалось, что страница в windows-1251 кодировке и выдает &lt;code&gt;�&lt;/code&gt;. Конвертируем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Проверяем наличие текста:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep &amp;quot;временно прекращен&amp;quot; &amp;gt; /dev/null 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Когда текст пропадет, grep выдаст ненулевой exitcode. Добавляем действие на этот случай.&lt;/p&gt;

&lt;p&gt;В начале я сделал как обычно делаю на сервере: отправил письмо через команду &lt;code&gt;mail&lt;/code&gt;. Оказалось, что письмо уходит в спам.
Не стал с этим разбираться, вместо этого буду показывать notification. Уведомление сделал через
&lt;a href=&#34;https://github.com/julienXX/terminal-notifier&#34; target=&#34;_blank&#34;&gt;julienXX/terminal-notifier&lt;/a&gt; (Mac OS),
но тут опять вышел облом: уведомление нельзя показывать бесконечно, если я окажусь в это время не перед экраном,
я об этом не узнаю. Поэтому буду еще и открывать страницу заказа в браузере. В итоге получилось вот это:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep &amp;quot;временно прекращен&amp;quot; &amp;gt; /dev/null || { \
  echo &amp;quot;BF order started&amp;quot; | terminal-notifier &amp;amp;&amp;amp; \
  open http://bakerflavors.ru/formbf.htm \
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>E.ggtimer: таймер в пару кликов в любом браузере</title>
      <link>http://blog.popstas.ru/blog/2016/01/31/timer-in-browser-with-1-second-time-to-start/</link>
      <pubDate>Sun, 31 Jan 2016 01:43:24 +0000</pubDate>
      
      <guid>http://blog.popstas.ru/blog/2016/01/31/timer-in-browser-with-1-second-time-to-start/</guid>
      <description>&lt;p&gt;Бывает, что надо вспомнить о чем-то в ближайшее время: выключить чайник, выйти к подъезду через 10 минут,
бросить заниматься фигней через полчаса - для таких вещей идеально подходит таймер. От таймера требуется только одно:
возможность установить его в течение 5 секунд. Недавно я нашел такой с такими плюсами:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Настроить нужно один раз, после этого будет работать на всех системах, если включена синхронизация настроек браузера&lt;/li&gt;
&lt;li&gt;Пользоваться легко&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UPD 05.03.2017: до сих пор пользуюсь через раз, либо этим способом, либо: &amp;ldquo;Окей, гугл, таймер на пять минут&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.popstas.ru/images/2016-01/eggtimer.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://e.ggtimer.com&#34; target=&#34;_blank&#34;&gt;http://e.ggtimer.com&lt;/a&gt; - с виду ничего особенного (так и есть), мне понравилась простота и задание времени через URL.
Какое-то время я пользовался им так: создал 2 таймера, на 5 и на 10 минут, сделал на них закладки на панель закладок.
Это не очень удобно по 2 причинам: на chrome мне жалко места на панели, а на firefox у меня панели закладок нет.&lt;/p&gt;

&lt;p&gt;Выход такой: оба браузера поддерживают пользовательские поисковые системы, сделаем такие.&lt;/p&gt;

&lt;h3 id=&#34;firefox&#34;&gt;Firefox&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Добавить в закладки &lt;a href=&#34;http://e.ggtimer.com/%smin&#34; target=&#34;_blank&#34;&gt;http://e.ggtimer.com/%smin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Находим эту закладку в списке и делаем ей Keyword: t&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;chrome&#34;&gt;Chrome&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Настройки - Настроить поисковые системы&lt;/li&gt;
&lt;li&gt;Добавить систему &lt;code&gt;e.ggtimer&lt;/code&gt; - &lt;code&gt;t&lt;/code&gt; - &lt;code&gt;http://e.ggtimer.com/%smin&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;После этого таймер на 5 минут ставится так:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Выбираем любой браузер&lt;/li&gt;
&lt;li&gt;Ставим фокус на поисковую строку (&lt;code&gt;F6&lt;/code&gt; / &lt;code&gt;Ctrl+L&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Пишем &lt;code&gt;t 5&lt;/code&gt;, &lt;code&gt;Enter&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;На самом деле в Firefox не синхронизируется Keyword закладок, придется прописывать на каждой системе.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>