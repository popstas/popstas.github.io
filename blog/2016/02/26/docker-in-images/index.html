<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
  
  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  

  
  <title>Docker в картинках</title>

  
  
  <link rel="stylesheet" href="https://blog.popstas.ru/css/hugo-octopress.css">

  
  
    <link rel="stylesheet" href="https://blog.popstas.ru/css/custom.css">
  

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://blog.popstas.ru/favicon.png" rel="icon">

  
  
  

  

  <meta name="description" content="">
  <meta name="keywords" content="">

  <meta name="author" content="Stanislav Popov">

  
  <meta name="generator" content="Hugo 0.66.0" />

  
  

</head>
<body>


<header role="banner"><hgroup>
  
  <div><a href="https://blog.popstas.ru/">Popstas</a></div>
    <div>Записки о Linux</div>
</hgroup></header>


<nav role="navigation">

<ul class="main-navigation">
  
  
</ul>


<ul class="subscription">
  
    
        <a href="http://feeds.feedburner.com/popstas" target="_blank" type="application/rss+xml" title="RSS"><i class="fa fa-rss-square fa-lg"></i></a>
    
  

</ul>


</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article" itemscope="" itemtype="http://schema.org/Article">
        <meta itemprop="author publisher" content="Stanislav Popov">
        
        

<header>
    <p class="meta">26 Feb 2016, 21:29
         - 7 мин читать 

        
    </p>
    <h1 class="entry-title" itemprop="headline">
         Docker в картинках 
    </h1>
</header>


        <meta itemprop="mainEntityOfPage" content="https://blog.popstas.ru/blog/2016/02/26/docker-in-images/">
        <div class="entry-content" itemprop="articleBody">
          
          
          
          <p>Оставлю здесь <a href="http://habrahabr.ru/post/272145/">свой пост</a> с хабра.</p>
<p><em>Перевод поста <a href="http://merrigrove.blogspot.co.uk/2015/10/visualizing-docker-containers-and-images.html">Visualizing Docker Containers and Images</a>, от новичка к новичкам, автор на простых примерах объясняет базовые сущности и процессы в использовании docker.</em></p>
<p>Если вы не знаете, что такое Docker или не понимаете, как он соотносится с виртуальными машинами или с инструментами configuration management, то этот пост может показаться немного сложным.</p>
<p>Пост предназначен для тех, кто пытается освоить docker cli, понять, чем отличается контейнер и образ. В частности, будет объяснена разница между просто контейнером и запущенным контейнером.</p>
<p><!-- raw HTML omitted --></p>
<p>В процессе освоения нужно представить себе некоторые лежащие в основе детали, например, слои файловой системы UnionFS. В течение последней пары недель я изучал технологию, я новичок в мире docker, и командная строка docker показалась мне довольно сложной для освоения.</p>
<p>По-моему, понимание того, как технология работает изнутри - лучший способ быстро освоить новый инструмент и правильно его использовать. Часто новая технология разрабатывает новые модели абстракций и привносит новые термины и метафоры, которые могут быть как будто бы понятны в начале, но без четкого понимания затрудняют последующее использование инструмента.</p>
<p>Хорошим примером является Git. Я не мог понять Git, пока не понял его базовую модель, включая trees, blobs, commits, tags, tree-ish и прочее. Я думаю, что люди, не понимающие внутренности Git, не могут мастерски использовать этот инструмент.</p>
<h2 id="определение-образа-image">Определение образа (Image)</h2>
<p>Визуализация образа представлена ниже в двух видах. Образ можно определить как &ldquo;сущность&rdquo; или &ldquo;общий вид&rdquo; (union view) стека слоев только для чтения.</p>
<p><!-- raw HTML omitted --></p>
<p>Слева мы видим стек слоев для чтения. Они показаны только для понимания внутреннего устройства, они доступны вне запущенного контейнера на хост-системе. Важно то, что они доступны только для чтения (иммутабельны), а все изменения происходят в верхнем слое стека. Каждый слой может иметь одного родителя, родитель тоже имеет родителя и т.д. Слой верхнего уровня может быть использован как UnionFS (AUFS в моем случае с docker) и представлен в виде единой read-only файловой системы, в которой отражены все слои. Мы видим эту &ldquo;сущность&rdquo; образа на рисунке справа.</p>
<p>Если вы захотите посмотреть на эти слои в первозданном виде, вы можете найти их в файловой системе на хост-машине. Они не видны напрямую из запущенного контейнера. На моей хост-машине я могу найти образы в /var/lib/docker/aufs.</p>
<pre><code># sudo tree -L 1 /var/lib/docker/
/var/lib/docker/
├── aufs
├── containers
├── graph
├── init
├── linkgraph.db
├── repositories-aufs
├── tmp
├── trust
└── volumes

7 directories, 2 files
</code></pre><h2 id="определение-контейнера-container">Определение контейнера (Container)</h2>
<p>Контейнер можно назвать &ldquo;сущностью&rdquo; стека слоев с верхним слоем для записи.</p>
<p><!-- raw HTML omitted --></p>
<p>На изображении выше показано примерно то же самое, что на изображении про образ, кроме того, что верхний слой доступен для записи. Вы могли заметить, что это определение ничего не говорит о том, запущен контейнер или нет и это неспроста. Разделение контейнеров на запущенные и не запущенные устранило путаницу в моем понимании.</p>
<p>Контейнер определяет лишь слой для записи наверху образа (стека слоев для чтения). Он не запущен.</p>
<h2 id="определение-запущенного-контейнера">Определение запущенного контейнера</h2>
<p>Запущенный контейнер - это &ldquo;общий вид&rdquo; контейнера для чтения-записи и его изолированного пространства процессов. Ниже изображен контейнер в своем пространстве процессов.</p>
<p><!-- raw HTML omitted --></p>
<p>Изоляция файловой системы обеспечивается технологиями уровня ядра, cgroups, namespaces и другие, позволяют докеру быть такой перспективной технологией. Процессы в пространстве контейнера могут изменять, удалять или создавать файлы, которые сохраняются в верхнем слое для записи. Смотрите изображение:</p>
<p><!-- raw HTML omitted --></p>
<p>Чтобы проверить это, выполните команду на хост-машине:</p>
<pre><code>docker run ubuntu touch happiness.txt
</code></pre><p>Вы можете найти новый файл в слое для записи на хост-машине, даже если контейнер не запущен.</p>
<pre><code># find / -name happiness.txt
/var/lib/docker/aufs/diff/860a7b...889/happiness.txt
</code></pre><h2 id="определение-слоя-образа-image-layer">Определение слоя образа (Image layer)</h2>
<p>Наконец, мы определим слой образа. Изображение ниже представляет слой образа и дает нам понять, что слой - это не просто изменения в файловой системе.</p>
<p><!-- raw HTML omitted --></p>
<p>Метаданные - дополнительная информация о слое, которая позволяет докеру сохранять информацию во время выполнения и во время сборки. Оба вида слоев (для чтения и для записи) содержат метаданные.</p>
<p><!-- raw HTML omitted --></p>
<p>Кроме того, как мы уже упоминали раньше, каждый слой содержит указатель на родителя, используя id (на изображении родительские слои внизу). Если слой не указывает на родительский слой, значит он наверху стека.</p>
<p><!-- raw HTML omitted --></p>
<h3 id="расположение-метаданных">Расположение метаданных</h3>
<p>На данный момент (я понимаю, что разработчики docker могут позже сменить реализацию), метаданные слоев образов (для чтения) находятся в файле с именем &ldquo;json&rdquo; в папке /var/lib/docker/graph/id_слоя:</p>
<pre><code>/var/lib/docker/graph/e809f156dc985.../json
</code></pre><p>где &ldquo;e809f156dc985&hellip;&rdquo; - урезанный id слоя.</p>
<h2 id="свяжем-все-вместе">Свяжем все вместе</h2>
<p>Теперь, давайте посмотрим на команды, иллюстрированные понятными картинками.</p>
<h3 id="docker-create-image-id">docker create <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker create</code> добавляет слой для записи наверх стека слоев, найденного по <!-- raw HTML omitted -->. Команда не запускает контейнер.</p>
<p><!-- raw HTML omitted --></p>
<h3 id="docker-start-container-id">docker start <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker start</code> создает пространство процессов вокруг слоев контейнера. Может быть только одно пространство процессов на один контейнер.</p>
<h3 id="docker-run-image-id">docker run <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Один из первых вопросов, который задают люди (я тоже задавал): &ldquo;В чем разница между <code>docker start</code> и <code>docker run</code>?&rdquo; Одна из первоначальных целей этого поста - объяснить эту тонкость.</p>
<p><!-- raw HTML omitted --></p>
<p>Как мы видим, команда <code>docker run</code> находит образ, создает контейнер поверх него и запускает контейнер. Это сделано для удобства и скрывает детали двух команд.</p>
<p>Продолжая сравнение с освоением Git, я скажу, что <code>docker run</code> очень похожа на <code>git pull</code>. Так же, как и <code>git pull</code> (который объединяет <code>git fetch</code> и <code>git merge</code>), команда <code>docker run</code> объединяет две команды, которые могут использоваться и независимо. Это удобно, но поначалу может ввести в заблуждение.</p>
<h3 id="docker-ps">docker ps</h3>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker ps</code> выводит список запущенных контейнеров на вашей хост-машине. Важно понимать, что в этот список входят только запущенные контейнеры, не запущенные контейнеры скрыты. Чтобы посмотреть список всех контейнеров, нужно использовать следующую команду.</p>
<h3 id="docker-ps--a">docker ps -a</h3>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker ps -a</code>, где <code>a</code> - сокращение от <code>all</code> выводит список всех контейнеров, независимо от их состояния.</p>
<h3 id="docker-images">docker images</h3>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker images</code> выводит список образов верхнего уровня (top-level images). Фактически, ничего особенного не отличает образ от слоя для чтения. Только те образы, которые имеют присоединенные контейнеры или те, что были получены с помощью pull, считаются образами верхнего уровня. Это различие нужно для удобства, так как за каждым образом верхнего уровня может быть множество слоев.</p>
<h3 id="docker-images--a">docker images -a</h3>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker images -a</code> выводит все образы на хост-машине. Это фактически список всех слоев для чтения в системе. Если вы хотите увидеть все слои одного образа, воспользуйтесь командой <code>docker history</code>.</p>
<h3 id="docker-stop-container-id">docker stop <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker stop</code> посылает сигнал SIGTERM запущенному контейнеру, что мягко останавливает все процессы в пространстве процессов контейнера. В результате мы получаем не запущенный контейнер.</p>
<h3 id="docker-kill-container-id">docker kill <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker kill</code> посылает сигнал SIGKILL, что немедленно завершает все процессы в текущем контейнере. Это почти то же самое, что нажать Ctrl+\ в терминале.</p>
<h3 id="docker-pause-container-id">docker pause <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>В отличие от <code>docker stop</code> и <code>docker kill</code>, которые посылают настоящие UNIX сигналы процессам контейнера, команда <code>docker pause</code> используют специальную возможность cgroups для заморозки запущенного пространства процессов. Подробности можно прочитать <a href="https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt">здесь</a>, если вкратце, отправки сигнала Ctrl+Z (SIGTSTP) не достаточно, чтобы заморозить все процессы в пространстве контейнера.</p>
<h3 id="docker-rm-container-id">docker rm <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker rm</code> удаляет слой для записи, который определяет контейнер на хост-системе. Должна быть запущена на остановленном контейнерах. Удаляет файлы.</p>
<h3 id="docker-rmi-image-id">docker rmi <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker rmi</code> удаляет слой для чтения, который определяет &ldquo;сущность&rdquo; образа. Она удаляет образ с хост-системы, но образ все еще может быть получен из репозитория через <code>docker pull</code>. Вы можете использовать <code>docker rmi</code> только для слоев верхнего уровня (или образов), для удаления промежуточных слоев нужно использовать <code>docker rmi -f</code>.</p>
<h3 id="docker-commit-container-id">docker commit <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --> или <!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker commit</code> берет верхний уровень контейнера, тот, что для записи и превращает его в слой для чтения. Это фактически превращает контейнер (вне зависимости от того, запущен ли он) в неизменяемый образ.</p>
<p><!-- raw HTML omitted --></p>
<h3 id="docker-build">docker build</h3>
<p>До:</p>
<p>Dockerfile <!-- raw HTML omitted --> и <!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted -->
Со многими другими слоями.</p>
<p>Команда <code>docker build</code> интересна тем, что запускает целый ряд команд:
<!-- raw HTML omitted --></p>
<p>На изображении выше мы видим, как команда build использует значение инструкции FROM из файла Dockerfile как базовый образ после чего:</p>
<ol>
<li>запускает контейнер (create и start)</li>
<li>изменяет слой для записи</li>
<li>делает commit
На каждой итерации создается новый слой. При исполнении <code>docker build</code> может создаваться множество слоев.</li>
</ol>
<h3 id="docker-exec-running-container-id">docker exec <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker exec</code> применяется к запущенному контейнеру, запускает новый процесс внутри пространства процессов контейнера.</p>
<h3 id="docker-inspect-container-id--image-id">docker inspect <!-- raw HTML omitted --> | <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --> или <!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker inspect</code> получает метаданные верхнего слоя контейнера или образа.</p>
<h3 id="docker-save-image-id">docker save <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker save</code> создает один файл, который может быть использован для импорта образа на другую хост-систему. В отличие от команды <code>export</code>, она сохраняет все слои и их метаданные. Может быть применена только к образам.</p>
<h3 id="docker-export-container-id">docker export <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker export</code> создает tar архив с содержимым файлов контейнера, в результате получается папка, пригодная для использования вне docker. Команда убирает слои и их метаданные. Может быть применена только для контейнеров.</p>
<h3 id="docker-history-image-id">docker history <!-- raw HTML omitted --></h3>
<p>До:</p>
<p><!-- raw HTML omitted --></p>
<p>После:</p>
<p><!-- raw HTML omitted --></p>
<p>Команда <code>docker history</code> принимает <!-- raw HTML omitted --> и рекурсивно выводит список всех слоев-родителей образа (которые тоже могут быть образами)</p>
<h2 id="итог">Итог</h2>
<p>Я надеюсь, вам понравилась эта визуализация контейнеров и образов. Есть много других команд (pull, search, restart, attach и другие), которые могут или не могут быть объяснены моими сравнениями.</p>
        </div>
        

<footer>
  <p class="meta">
    
    <time itemprop="datePublished" content="2016-02-26T21:29:45UTC">26 Feb 2016, 21:29</time>
    
      <span class="categories">
        , теги:
        
          <a class="category" href="https://blog.popstas.ru/tags/docker">docker</a><meta itemprop="about" content="docker">  
    
    </span>
  </p>

  
  <div class="sharing">
  
  <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
    <a href="https://www.addtoany.com/share"></a>
    <a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_google_plus"></a><a class="a2a_button_vk"></a><a class="a2a_button_pocket"></a>
  </div>
  <script>
    var a2a_config = a2a_config || {};
    a2a_config.locale = "ru";
    a2a_config.color_main = "undefined";
    a2a_config.color_border = "undefined";
    a2a_config.color_link_text = "undefined";
    a2a_config.color_link_text_hover = "undefined";
    a2a_config.color_bg = "undefined";
    a2a_config.color_arrow = "undefined";
    a2a_config.color_arrow_hover = "undefined";
    a2a_config.prioritize = ["facebook", "twitter", "google_plus", "pocket", "vk"];
  </script>
  <script async src="https://static.addtoany.com/menu/page.js"></script>
  
</div>

  

  

  <p class="meta">
    
        <a class="basic-alignment left" href="https://blog.popstas.ru/blog/2016/02/25/big-touchpad-as-mouse-replacement/" title="Большой тачпад как замена мышки">Большой тачпад как замена мышки</a>
    

    
      <a class="basic-alignment right" href="https://blog.popstas.ru/blog/2016/02/27/content-consumption-pyramid-rss/" title="Как я обрабатываю входящие потоки контента через RSS и Pocket или моя воронка статей">Как я обрабатываю входящие потоки контента через RSS и Pocket или моя воронка статей</a>
    
  </p>
      <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    
    

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'popstas';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    

    <p>
      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      <a target="_blank" href="https://github.com/popstas/" title="https://github.com/popstas/"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a target="_blank" href="https://twitter.com/popstas/" title="https://twitter.com/popstas/"><i class="fa fa-twitter fa-3x"></i></a>
       
      
      
      
      
      
      
      <a target="_blank" href="tg://resolve?domain=popstas" title="popstas"><i class="fa fa-telegram fa-3x"></i></a>
      <a target="_blank" href="mailto:popstas@gmail.com" title="popstas@gmail.com"><i class="fa fa-at fa-3x"></i></a>

    
    
    </li>
  </ul>

  

  

  
  
  
    
      <section class="even">
        <h4>Последние посты:</h4>
        <ul id="recent_posts">
          
            <li class="post">
              <a href="/tags/offtop/">offtop</a>
            </li>
          
            <li class="post">
              <a href="/">Popstas</a>
            </li>
          
            <li class="post">
              <a href="/post/">Posts</a>
            </li>
          
            <li class="post">
              <a href="/tags/">Tags</a>
            </li>
          
            <li class="post">
              <a href="/blog/2019/12/29/new-year-2019/">Итоги 2019 года</a>
            </li>
          
        </ul>
      </section>
    
  

  

  
</aside>

  </div>
</div>

<footer role="contentinfo">
  <p>Copyright &copy; 2015-2020 Stanislav Popov -
  <span class="credit">Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/">Hugo-Octopress</a> theme.
</p>

</footer>


<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WPJWVXB');</script>
  




<script type="text/javascript" >
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(51681281, "init", {
       id:51681281,
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/51681281" style="position:absolute; left:-9999px;" alt="" /></div></noscript>


</body>
</html>

